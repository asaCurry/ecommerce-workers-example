// packages/storage-file/src/index.ts
import { existsSync } from "fs";
import path2 from "path";
import {
  MiniflareError,
  defaultClock,
  sanitisePath,
  viewToArray
} from "@miniflare/shared";
import { LocalStorage } from "@miniflare/storage-memory";

// packages/storage-file/src/helpers.ts
import fs from "fs/promises";
import path from "path";
function onNotFound(promise, value) {
  return promise.catch((e) => {
    if (e.code === "ENOENT")
      return value;
    throw e;
  });
}
function readFile(filePath, decode) {
  return onNotFound(fs.readFile(filePath, decode && "utf8"), void 0);
}
async function writeFile(filePath, data) {
  await fs.mkdir(path.dirname(filePath), { recursive: true });
  await fs.writeFile(filePath, data, typeof data === "string" ? "utf8" : void 0);
}
function deleteFile(filePath) {
  return onNotFound(fs.unlink(filePath).then(() => true), false);
}
function readDir(filePath) {
  return onNotFound(fs.readdir(filePath), []);
}
async function* walk(rootPath) {
  const fileNames = await readDir(rootPath);
  for (const fileName of fileNames) {
    const filePath = path.join(rootPath, fileName);
    if ((await fs.stat(filePath)).isDirectory()) {
      yield* walk(filePath);
    } else {
      yield filePath;
    }
  }
}

// packages/storage-file/src/index.ts
var metaSuffix = ".meta.json";
var FileStorageError = class extends MiniflareError {
};
var FileStorage = class extends LocalStorage {
  constructor(root, sanitise = true, clock = defaultClock) {
    super(clock);
    this.sanitise = sanitise;
    this.root = path2.resolve(root);
  }
  root;
  keyPath(key) {
    const sanitisedKey = this.sanitise ? sanitisePath(key) : key;
    const filePath = path2.join(this.root, sanitisedKey);
    return [
      filePath.startsWith(this.root) ? filePath : void 0,
      sanitisedKey !== key
    ];
  }
  async meta(keyFilePath) {
    const metaString = await readFile(keyFilePath + metaSuffix, true);
    return metaString ? JSON.parse(metaString) : {};
  }
  async hasMaybeExpired(key) {
    const [filePath] = this.keyPath(key);
    if (!filePath)
      return;
    if (!existsSync(filePath))
      return;
    const meta = await this.meta(filePath);
    return { expiration: meta.expiration, metadata: meta.metadata };
  }
  async getMaybeExpired(key) {
    const [filePath] = this.keyPath(key);
    if (!filePath)
      return;
    const value = await readFile(filePath);
    if (value === void 0)
      return;
    const meta = await this.meta(filePath);
    return {
      value: viewToArray(value),
      expiration: meta.expiration,
      metadata: meta.metadata
    };
  }
  async put(key, { value, expiration, metadata }) {
    const [filePath, sanitised] = this.keyPath(key);
    if (!filePath) {
      throw new FileStorageError("ERR_TRAVERSAL", "Cannot store values outside of storage root directory");
    }
    await writeFile(filePath, value);
    const metaFilePath = filePath + metaSuffix;
    if (expiration !== void 0 || metadata !== void 0 || sanitised) {
      await writeFile(metaFilePath, JSON.stringify({ key, expiration, metadata }));
    } else {
      await deleteFile(metaFilePath);
    }
  }
  async deleteMaybeExpired(key) {
    const [filePath] = this.keyPath(key);
    if (!filePath)
      return false;
    const existed = await deleteFile(filePath);
    await deleteFile(filePath + metaSuffix);
    return existed;
  }
  async listAllMaybeExpired() {
    const keys = [];
    for await (const filePath of walk(this.root)) {
      if (filePath.endsWith(metaSuffix))
        continue;
      const name = filePath.substring(this.root.length + 1);
      const meta = await this.meta(filePath);
      const realName = meta?.key ?? name;
      keys.push({
        name: realName,
        expiration: meta.expiration,
        metadata: meta.metadata
      });
    }
    return keys;
  }
};
export {
  FileStorage,
  FileStorageError
};
//# sourceMappingURL=index.js.map
