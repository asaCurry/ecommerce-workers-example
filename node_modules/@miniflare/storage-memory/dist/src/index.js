// packages/storage-memory/src/helpers.ts
import {
  base64Decode,
  base64Encode,
  nonCircularClone
} from "@miniflare/shared";
function cloneMetadata(metadata) {
  return metadata && nonCircularClone(metadata);
}
var collator = new Intl.Collator();
function listFilterMatch(options, name) {
  return !(options?.prefix && !name.startsWith(options.prefix) || options?.start && collator.compare(name, options.start) < 0 || options?.end && collator.compare(name, options.end) >= 0);
}
function listPaginate(options, keys) {
  const direction = options?.reverse ? -1 : 1;
  keys.sort((a, b) => direction * collator.compare(a.name, b.name));
  const startAfter = options?.cursor ? base64Decode(options.cursor) : "";
  let startIndex = 0;
  if (startAfter !== "") {
    startIndex = keys.findIndex(({ name }) => name === startAfter);
    if (startIndex === -1)
      startIndex = keys.length;
    startIndex++;
  }
  const endIndex = options?.limit === void 0 ? keys.length : startIndex + options.limit;
  const nextCursor = endIndex < keys.length ? base64Encode(keys[endIndex - 1].name) : "";
  keys = keys.slice(startIndex, endIndex);
  return { keys, cursor: nextCursor };
}

// packages/storage-memory/src/local.ts
import {
  Storage,
  defaultClock,
  millisToSeconds
} from "@miniflare/shared";
var LocalStorage = class extends Storage {
  constructor(clock = defaultClock) {
    super();
    this.clock = clock;
  }
  expired({ expiration }, time = this.clock()) {
    return expiration !== void 0 && expiration <= millisToSeconds(time);
  }
  async has(key) {
    const stored = await this.hasMaybeExpired(key);
    if (stored === void 0)
      return false;
    if (this.expired(stored)) {
      await this.deleteMaybeExpired(key);
      return false;
    }
    return true;
  }
  async get(key) {
    const stored = await this.getMaybeExpired(key);
    if (stored === void 0)
      return void 0;
    if (this.expired(stored)) {
      await this.deleteMaybeExpired(key);
      return void 0;
    }
    return stored;
  }
  async delete(key) {
    const stored = await this.hasMaybeExpired(key);
    const expired = stored !== void 0 && this.expired(stored);
    const deleted = await this.deleteMaybeExpired(key);
    if (!deleted)
      return false;
    return !expired;
  }
  async list(options) {
    const time = this.clock();
    const deletePromises = [];
    let keys = await this.listAllMaybeExpired();
    keys = keys.filter((stored) => {
      if (this.expired(stored, time)) {
        deletePromises.push(this.deleteMaybeExpired(stored.name));
        return false;
      }
      return listFilterMatch(options, stored.name);
    });
    const res = listPaginate(options, keys);
    await Promise.all(deletePromises);
    return res;
  }
};

// packages/storage-memory/src/memory.ts
import { defaultClock as defaultClock2 } from "@miniflare/shared";
var MemoryStorage = class extends LocalStorage {
  constructor(map = new Map(), clock = defaultClock2) {
    super(clock);
    this.map = map;
  }
  hasMaybeExpired(key) {
    const stored = this.map.get(key);
    return stored && {
      expiration: stored.expiration,
      metadata: cloneMetadata(stored.metadata)
    };
  }
  getMaybeExpired(key) {
    const stored = this.map.get(key);
    return stored && {
      value: stored.value.slice(),
      expiration: stored.expiration,
      metadata: cloneMetadata(stored.metadata)
    };
  }
  put(key, value) {
    this.map.set(key, {
      value: value.value.slice(),
      expiration: value.expiration,
      metadata: cloneMetadata(value.metadata)
    });
  }
  deleteMaybeExpired(key) {
    return this.map.delete(key);
  }
  static entryToStoredKey([name, { expiration, metadata }]) {
    return {
      name,
      expiration,
      metadata: cloneMetadata(metadata)
    };
  }
  listAllMaybeExpired() {
    return Array.from(this.map.entries()).map(MemoryStorage.entryToStoredKey);
  }
};
export {
  LocalStorage,
  MemoryStorage,
  cloneMetadata,
  listFilterMatch,
  listPaginate
};
//# sourceMappingURL=index.js.map
