// packages/watcher/src/index.ts
import assert from "assert";
import fs from "fs";
import path from "path";
import { debuglog } from "util";
var fsp = fs.promises;
var log = debuglog("mf-watch");
function withinDir(dir, file) {
  const rel = path.relative(dir, file);
  return !!rel && !rel.startsWith("..") && !path.isAbsolute(rel);
}
async function walkDirs(root, callback) {
  callback(root);
  const names = await fsp.readdir(root);
  await Promise.all(names.map(async (name) => {
    const filePath = path.join(root, name);
    if (!(await fsp.stat(filePath)).isDirectory())
      return;
    return walkDirs(filePath, callback);
  }));
}
var PathWatcher = class {
  constructor(options, filePath, callback) {
    this.options = options;
    this.filePath = filePath;
    this.callback = callback;
  }
  watchFileListener;
  watcher;
  watchers;
  lastMtimes;
  get watching() {
    return !!(this.watchFileListener || this.watcher || this.watchers || this.lastMtimes);
  }
  startCreateWatcher() {
    assert(!this.watching);
    log(`${this.filePath}: polling for create...`);
    this.watchFileListener = (curr) => {
      if (curr.mtimeMs === 0)
        return;
      log(`${this.filePath}: created, tidying up temporary watcher...`);
      fs.unwatchFile(this.filePath, this.watchFileListener);
      this.watchFileListener = void 0;
      this.callback();
      void this.start();
    };
    fs.watchFile(this.filePath, { interval: this.options.createPollInterval }, this.watchFileListener);
  }
  startPollingWatcher() {
    assert(!this.watching);
    log(`${this.filePath}: polling...`);
    this.watchFileListener = (curr, prev) => {
      log(`${this.filePath}: ${prev.mtimeMs} -> ${curr.mtimeMs}`);
      if (curr.mtimeMs === 0) {
        this.callback();
        this.dispose();
        this.startCreateWatcher();
      } else if (curr.mtimeMs !== prev.mtimeMs) {
        this.callback();
      }
    };
    fs.watchFile(this.filePath, { interval: this.options.pollInterval }, this.watchFileListener);
  }
  listener = async (event, fileName) => {
    log(`${this.filePath}: ${event}: ${fileName}`);
    if (fileName) {
      try {
        const resolved = path.resolve(this.filePath, fileName);
        const mtime = (await fsp.stat(resolved)).mtimeMs;
        const previousMtime = this.lastMtimes?.get(resolved);
        if (previousMtime === mtime) {
          log(`${this.filePath}: ${resolved}: ignored spurious event`);
          return;
        }
        this.lastMtimes?.set(resolved, mtime);
      } catch {
      }
    }
    this.callback();
    if (!fs.existsSync(this.filePath)) {
      this.dispose();
      this.startCreateWatcher();
    }
  };
  startDeletedWatcher() {
    this.watchFileListener = (curr) => {
      if (curr.mtimeMs === 0) {
        this.callback();
        this.dispose();
        this.startCreateWatcher();
      }
    };
    fs.watchFile(this.filePath, { interval: this.options.pollInterval }, this.watchFileListener);
  }
  startPlatformRecursiveWatcher() {
    assert(!this.watching);
    log(`${this.filePath}: recursively watching with platform...`);
    this.lastMtimes = new Map();
    this.watcher = fs.watch(this.filePath, { recursive: true }, this.listener);
    this.startDeletedWatcher();
  }
  async startRecursiveWatcher() {
    assert(!this.watching);
    log(`${this.filePath}: recursively watching...`);
    const watchers = this.watchers = new Map();
    this.lastMtimes = new Map();
    const update = async (dir, event, fileName) => {
      let dirIsDirectory = false;
      try {
        dirIsDirectory = (await fsp.stat(dir)).isDirectory();
      } catch {
      }
      if (!dirIsDirectory) {
        log(`${this.filePath}: ${dir} is no longer a directory, resetting...`);
        this.callback();
        this.dispose();
        await this.start();
        return;
      }
      const filePath = path.join(dir, fileName);
      await this.listener(event, filePath);
      try {
        if ((await fsp.stat(filePath)).isDirectory()) {
          await walkDirs(filePath, walkCallback);
        }
      } catch (e) {
        if (e.code !== "ENOENT")
          throw e;
        for (const [watchedPath, watcher] of watchers.entries()) {
          if (filePath === watchedPath || withinDir(filePath, watchedPath)) {
            watcher.close();
            watchers.delete(watchedPath);
          }
        }
      }
      log(`${this.filePath}: watching ${[...watchers.keys()].join(",")}`);
    };
    const walkCallback = (dir) => {
      if (!watchers.has(dir)) {
        watchers.set(dir, fs.watch(dir, update.bind(this, dir)));
      }
    };
    try {
      await walkDirs(this.filePath, walkCallback);
      this.startDeletedWatcher();
    } catch (e) {
      if (e.code !== "ENOENT")
        throw e;
      this.dispose();
      this.startCreateWatcher();
    }
  }
  async start() {
    try {
      const stat = await fsp.stat(this.filePath);
      if (stat.isDirectory()) {
        if (this.options.forceRecursive) {
          return await this.startRecursiveWatcher();
        } else {
          return this.startPlatformRecursiveWatcher();
        }
      } else {
        return this.startPollingWatcher();
      }
    } catch (e) {
      this.dispose();
      if (e.code === "ENOENT") {
        return this.startCreateWatcher();
      }
      if (e.code === "ERR_FEATURE_UNAVAILABLE_ON_PLATFORM") {
        return await this.startRecursiveWatcher();
      }
      throw e;
    }
  }
  dispose() {
    log(`${this.filePath}: disposing...`);
    if (this.watchFileListener) {
      fs.unwatchFile(this.filePath, this.watchFileListener);
      this.watchFileListener = void 0;
    }
    this.watcher?.close();
    this.watcher = void 0;
    if (this.watchers) {
      for (const watcher of this.watchers.values())
        watcher.close();
      this.watchers = void 0;
    }
    this.lastMtimes = void 0;
    assert(!this.watching);
  }
};
var Watcher = class {
  #watchers = new Map();
  #callback;
  #options;
  constructor(callback, options) {
    this.#callback = callback;
    this.#options = {
      debounce: options?.debounce ?? 50,
      pollInterval: options?.pollInterval ?? 250,
      createPollInterval: options?.createPollInterval ?? 1e3,
      forceRecursive: options?.forceRecursive ?? false
    };
  }
  async watch(paths) {
    if (typeof paths === "string")
      paths = [paths];
    for (const rawPath of paths) {
      const resolved = path.resolve(rawPath);
      if (this.#watchers.has(resolved)) {
        log(`${resolved}: already watching`);
        continue;
      }
      log(`${resolved}: watching...`);
      let debounceHandle;
      const callback = () => {
        clearTimeout(debounceHandle);
        debounceHandle = setTimeout(this.#callback, this.#options.debounce, resolved);
      };
      const watcher = new PathWatcher(this.#options, resolved, callback);
      this.#watchers.set(resolved, watcher);
      await watcher.start();
    }
  }
  unwatch(paths) {
    if (typeof paths === "string")
      paths = [paths];
    for (const rawPath of paths) {
      const resolved = path.resolve(rawPath);
      log(`${resolved}: unwatching...`);
      this.#watchers.get(resolved)?.dispose();
      this.#watchers.delete(resolved);
    }
  }
  dispose() {
    for (const watcher of this.#watchers.values())
      watcher.dispose();
    this.#watchers.clear();
  }
};
export {
  Watcher,
  withinDir
};
//# sourceMappingURL=index.js.map
