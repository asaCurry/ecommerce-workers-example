// packages/html-rewriter/src/plugin.ts
import { Plugin } from "@miniflare/shared";

// packages/html-rewriter/src/rewriter.ts
import { TransformStream } from "stream/web";
import { Response } from "@miniflare/core";
function transformToArray(chunk) {
  if (chunk instanceof Uint8Array) {
    return chunk;
  } else if (chunk instanceof ArrayBuffer) {
    return new Uint8Array(chunk);
  } else {
    return new Uint8Array(chunk.buffer, chunk.byteOffset, chunk.byteLength);
  }
}
var HTMLRewriter = class {
  #elementHandlers = [];
  #documentHandlers = [];
  on(selector, handlers) {
    this.#elementHandlers.push([selector, handlers]);
    return this;
  }
  onDocument(handlers) {
    this.#documentHandlers.push(handlers);
    return this;
  }
  transform(response) {
    let rewriter;
    const transformStream = new TransformStream({
      start: async (controller) => {
        const { HTMLRewriter: BaseHTMLRewriter } = await import("html-rewriter-wasm");
        rewriter = new BaseHTMLRewriter((output) => {
          if (output.length !== 0)
            controller.enqueue(output);
        });
        for (const [selector, handlers] of this.#elementHandlers) {
          rewriter.on(selector, handlers);
        }
        for (const handlers of this.#documentHandlers) {
          rewriter.onDocument(handlers);
        }
      },
      transform: async (chunk) => {
        if (chunk instanceof ArrayBuffer || ArrayBuffer.isView(chunk)) {
          try {
            return await rewriter.write(transformToArray(chunk));
          } catch (e) {
            rewriter.free();
            throw e;
          }
        } else {
          rewriter.free();
          const isString = typeof chunk === "string";
          throw new TypeError("This TransformStream is being used as a byte stream, but received " + (isString ? "a string on its writable side. If you wish to write a string, you'll probably want to explicitly UTF-8-encode it with TextEncoder." : "an object of non-ArrayBuffer/ArrayBufferView type on its writable side."));
        }
      },
      flush: async () => {
        try {
          return await rewriter.end();
        } finally {
          rewriter.free();
        }
      }
    });
    const body = response.body;
    const res = new Response(body?.pipeThrough(transformStream), response);
    res.headers.delete("Content-Length");
    return res;
  }
};

// packages/html-rewriter/src/plugin.ts
var HTMLRewriterPlugin = class extends Plugin {
  constructor(ctx) {
    super(ctx);
  }
  setup() {
    return { globals: { HTMLRewriter } };
  }
};
export {
  HTMLRewriter,
  HTMLRewriterPlugin
};
//# sourceMappingURL=index.js.map
