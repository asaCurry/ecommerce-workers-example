var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __decorateClass = (decorators, target, key, kind) => {
  var result = kind > 1 ? void 0 : kind ? __getOwnPropDesc(target, key) : target;
  for (var i = decorators.length - 1, decorator; i >= 0; i--)
    if (decorator = decorators[i])
      result = (kind ? decorator(target, key, result) : decorator(result)) || result;
  if (kind && result)
    __defProp(target, key, result);
  return result;
};

// packages/scheduler/src/index.ts
import {
  ReloadEvent,
  logResponse
} from "@miniflare/core";

// packages/scheduler/src/plugin.ts
import {
  MiniflareError,
  Option,
  OptionType,
  Plugin
} from "@miniflare/shared";
var SchedulerError = class extends MiniflareError {
};
var SchedulerPlugin = class extends Plugin {
  crons;
  #validatedCrons = [];
  constructor(ctx, options) {
    super(ctx);
    this.assignOptions(options);
  }
  get validatedCrons() {
    return this.#validatedCrons;
  }
  async setup() {
    if (!this.crons?.length) {
      this.#validatedCrons = [];
      return;
    }
    const { parseCronExpression } = await import("cron-schedule");
    const validatedCrons = Array(this.crons.length);
    for (let i = 0; i < this.crons.length; i++) {
      const spec = this.crons[i];
      try {
        const cron = parseCronExpression(spec);
        cron.toString = () => spec;
        validatedCrons[i] = cron;
      } catch (e) {
        throw new SchedulerError("ERR_INVALID_CRON", `Unable to parse CRON "${spec}": ${e.message}`);
      }
    }
    this.#validatedCrons = validatedCrons;
  }
};
__decorateClass([
  Option({
    type: OptionType.ARRAY,
    alias: "t",
    description: "CRON expression for triggering scheduled events",
    logName: "CRON Expressions",
    fromWrangler: ({ triggers }) => triggers?.crons
  })
], SchedulerPlugin.prototype, "crons", 2);

// packages/scheduler/src/index.ts
var kReload = Symbol("kReload");
var Scheduler = class {
  constructor(mf, cronScheduler = import("cron-schedule").then((module) => module.TimerBasedCronScheduler)) {
    this.mf = mf;
    this.cronScheduler = cronScheduler;
    mf.addEventListener("reload", this[kReload]);
  }
  previousValidatedCrons;
  scheduledHandles;
  [kReload] = async (event) => {
    const validatedCrons = event.plugins.SchedulerPlugin.validatedCrons;
    if (this.previousValidatedCrons === validatedCrons)
      return;
    this.previousValidatedCrons = validatedCrons;
    const cronScheduler = await this.cronScheduler;
    this.scheduledHandles?.forEach((handle) => cronScheduler.clearTimeoutOrInterval(handle));
    if (!validatedCrons.length)
      return;
    this.scheduledHandles = validatedCrons?.map((cron) => {
      const spec = cron.toString();
      return cronScheduler.setInterval(cron, async () => {
        const start = process.hrtime();
        const waitUntil = this.mf.dispatchScheduled(void 0, spec);
        await logResponse(this.mf.log, {
          start,
          method: "SCHD",
          url: spec,
          waitUntil
        });
      });
    });
  };
  async dispose() {
    this.mf.removeEventListener("reload", this[kReload]);
    const cronScheduler = await this.cronScheduler;
    this.scheduledHandles?.forEach((handle) => cronScheduler.clearTimeoutOrInterval(handle));
  }
};
async function startScheduler(mf, cronScheduler) {
  const scheduler = new Scheduler(mf, cronScheduler);
  await scheduler[kReload](new ReloadEvent(await mf.getPlugins(), false));
  return scheduler;
}
export {
  Scheduler,
  SchedulerError,
  SchedulerPlugin,
  startScheduler
};
//# sourceMappingURL=index.js.map
