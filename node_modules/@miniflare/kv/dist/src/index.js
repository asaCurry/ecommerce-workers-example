var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __decorateClass = (decorators, target, key, kind) => {
  var result = kind > 1 ? void 0 : kind ? __getOwnPropDesc(target, key) : target;
  for (var i = decorators.length - 1, decorator; i >= 0; i--)
    if (decorator = decorators[i])
      result = (kind ? decorator(target, key, result) : decorator(result)) || result;
  if (kind && result)
    __defProp(target, key, result);
  return result;
};

// packages/kv/src/namespace.ts
import { arrayBuffer } from "stream/consumers";
import { ReadableStream } from "stream/web";
import {
  defaultClock,
  millisToSeconds,
  viewToArray,
  viewToBuffer,
  waitForOpenInputGate,
  waitForOpenOutputGate
} from "@miniflare/shared";
var MIN_CACHE_TTL = 60;
var MAX_LIST_KEYS = 1e3;
var MAX_KEY_SIZE = 512;
var MAX_VALUE_SIZE = 25 * 1024 * 1024;
var MAX_METADATA_SIZE = 1024;
var keyTypeError = " on 'KvNamespace': parameter 1 is not of type 'string'.";
var encoder = new TextEncoder();
var decoder = new TextDecoder();
var getValueTypes = new Set(["text", "json", "arrayBuffer", "stream"]);
function throwKVError(method, status, message) {
  throw new Error(`KV ${method} failed: ${status} ${message}`);
}
function validateKey(method, key) {
  if (key === "")
    throw new TypeError("Key name cannot be empty.");
  if (key === ".")
    throw new TypeError('"." is not allowed as a key name.');
  if (key === "..")
    throw new TypeError('".." is not allowed as a key name.');
  const keyLength = encoder.encode(key).byteLength;
  if (keyLength > MAX_KEY_SIZE) {
    throwKVError(method, 414, `UTF-8 encoded length of ${keyLength} exceeds key length limit of ${MAX_KEY_SIZE}.`);
  }
}
function validateGetOptions(options) {
  const string = typeof options === "string";
  const type = string ? options : options?.type ?? "text";
  const cacheTtl = string ? void 0 : options?.cacheTtl;
  if (cacheTtl && (isNaN(cacheTtl) || cacheTtl < MIN_CACHE_TTL)) {
    throwKVError("GET", 400, `Invalid cache_ttl of ${cacheTtl}. Cache TTL must be at least ${MIN_CACHE_TTL}.`);
  }
  if (!getValueTypes.has(type)) {
    throw new TypeError('Unknown response type. Possible types are "text", "arrayBuffer", "json", and "stream".');
  }
  return type;
}
function normaliseInt(value) {
  switch (typeof value) {
    case "string":
      return parseInt(value);
    case "number":
      return Math.round(value);
  }
}
function convertStoredToGetValue(stored, type) {
  switch (type) {
    case "text":
      return decoder.decode(stored);
    case "arrayBuffer":
      return viewToBuffer(stored);
    case "json":
      return JSON.parse(decoder.decode(stored));
    case "stream":
      return new ReadableStream({
        type: "bytes",
        async pull(controller) {
          await waitForOpenInputGate();
          controller.enqueue(stored);
          controller.close();
        }
      });
  }
}
var KVNamespace = class {
  #storage;
  #clock;
  constructor(storage, clock = defaultClock) {
    this.#storage = storage;
    this.#clock = clock;
  }
  async get(key, options) {
    if (typeof key !== "string") {
      throw new TypeError("Failed to execute 'get'" + keyTypeError);
    }
    validateKey("GET", key);
    const type = validateGetOptions(options);
    const stored = await this.#storage.get(key, true);
    await waitForOpenInputGate();
    if (stored === void 0)
      return null;
    return convertStoredToGetValue(stored.value, type);
  }
  async getWithMetadata(key, options) {
    if (typeof key !== "string") {
      throw new TypeError("Failed to execute 'getWithMetadata'" + keyTypeError);
    }
    validateKey("GET", key);
    const type = validateGetOptions(options);
    const storedValue = await this.#storage.get(key);
    await waitForOpenInputGate();
    if (storedValue === void 0)
      return { value: null, metadata: null };
    const { value, metadata = null } = storedValue;
    return { value: convertStoredToGetValue(value, type), metadata };
  }
  async put(key, value, options = {}) {
    if (typeof key !== "string") {
      throw new TypeError("Failed to execute 'put'" + keyTypeError);
    }
    validateKey("PUT", key);
    let stored;
    if (typeof value === "string") {
      stored = encoder.encode(value);
    } else if (value instanceof ReadableStream) {
      stored = new Uint8Array(await arrayBuffer(value));
    } else if (value instanceof ArrayBuffer) {
      stored = new Uint8Array(value);
    } else if (ArrayBuffer.isView(value)) {
      stored = viewToArray(value);
    } else {
      throw new TypeError("KV put() accepts only strings, ArrayBuffers, ArrayBufferViews, and ReadableStreams as values.");
    }
    const now = millisToSeconds(this.#clock());
    let expiration = normaliseInt(options.expiration);
    const expirationTtl = normaliseInt(options.expirationTtl);
    if (expirationTtl !== void 0) {
      if (isNaN(expirationTtl) || expirationTtl <= 0) {
        throwKVError("PUT", 400, `Invalid expiration_ttl of ${options.expirationTtl}. Please specify integer greater than 0.`);
      }
      if (expirationTtl < MIN_CACHE_TTL) {
        throwKVError("PUT", 400, `Invalid expiration_ttl of ${options.expirationTtl}. Expiration TTL must be at least ${MIN_CACHE_TTL}.`);
      }
      expiration = now + expirationTtl;
    } else if (expiration !== void 0) {
      if (isNaN(expiration) || expiration <= now) {
        throwKVError("PUT", 400, `Invalid expiration of ${options.expiration}. Please specify integer greater than the current number of seconds since the UNIX epoch.`);
      }
      if (expiration < now + MIN_CACHE_TTL) {
        throwKVError("PUT", 400, `Invalid expiration of ${options.expiration}. Expiration times must be at least ${MIN_CACHE_TTL} seconds in the future.`);
      }
    }
    if (stored.byteLength > MAX_VALUE_SIZE) {
      throwKVError("PUT", 413, `Value length of ${stored.byteLength} exceeds limit of ${MAX_VALUE_SIZE}.`);
    }
    const metadataLength = options.metadata && encoder.encode(JSON.stringify(options.metadata)).byteLength;
    if (metadataLength && metadataLength > MAX_METADATA_SIZE) {
      throwKVError("PUT", 413, `Metadata length of ${metadataLength} exceeds limit of ${MAX_METADATA_SIZE}.`);
    }
    await waitForOpenOutputGate();
    await this.#storage.put(key, {
      value: stored,
      expiration,
      metadata: options.metadata
    });
    await waitForOpenInputGate();
  }
  async delete(key) {
    if (typeof key !== "string") {
      throw new TypeError("Failed to execute 'delete'" + keyTypeError);
    }
    validateKey("DELETE", key);
    await waitForOpenOutputGate();
    await this.#storage.delete(key);
    await waitForOpenInputGate();
  }
  async list({
    prefix = "",
    limit = MAX_LIST_KEYS,
    cursor
  } = {}) {
    if (isNaN(limit) || limit < 1) {
      throwKVError("GET", 400, `Invalid key_count_limit of ${limit}. Please specify an integer greater than 0.`);
    }
    if (limit > MAX_LIST_KEYS) {
      throwKVError("GET", 400, `Invalid key_count_limit of ${limit}. Please specify an integer less than ${MAX_LIST_KEYS}.`);
    }
    const res = await this.#storage.list({ prefix, limit, cursor });
    await waitForOpenInputGate();
    return {
      keys: res.keys,
      cursor: res.cursor,
      list_complete: res.cursor === ""
    };
  }
};

// packages/kv/src/plugin.ts
import {
  Option,
  OptionType,
  Plugin
} from "@miniflare/shared";
var KVPlugin = class extends Plugin {
  kvNamespaces;
  kvPersist;
  constructor(ctx, options) {
    super(ctx);
    this.assignOptions(options);
  }
  async getNamespace(storage, namespace) {
    return new KVNamespace(await storage.storage(namespace, this.kvPersist));
  }
  async setup(storageFactory) {
    const bindings = {};
    for (const namespace of this.kvNamespaces ?? []) {
      bindings[namespace] = await this.getNamespace(storageFactory, namespace);
    }
    return { bindings };
  }
};
__decorateClass([
  Option({
    type: OptionType.ARRAY,
    name: "kv",
    alias: "k",
    description: "KV namespace to bind",
    logName: "KV Namespaces",
    fromWrangler: ({ kv_namespaces }) => kv_namespaces?.map(({ binding }) => binding)
  })
], KVPlugin.prototype, "kvNamespaces", 2);
__decorateClass([
  Option({
    type: OptionType.BOOLEAN_STRING,
    description: "Persist KV data (to optional path)",
    logName: "KV Persistence",
    fromWrangler: ({ miniflare }) => miniflare?.kv_persist
  })
], KVPlugin.prototype, "kvPersist", 2);
export {
  KVNamespace,
  KVPlugin
};
//# sourceMappingURL=index.js.map
