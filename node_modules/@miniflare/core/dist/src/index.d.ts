/// <reference types="node" />

import { Awaitable } from '@miniflare/shared';
import { BeforeSetupResult } from '@miniflare/shared';
import { Blob as Blob_2 } from 'buffer';
import { BodyInit as BodyInit_2 } from 'undici';
import { Compatibility } from '@miniflare/shared';
import { CompatibilityFlag } from '@miniflare/shared';
import { Context } from '@miniflare/shared';
import { FormData as FormData_2 } from 'undici';
import { Headers as Headers_2 } from 'undici';
import { Log } from '@miniflare/shared';
import { MiniflareError } from '@miniflare/shared';
import { ModuleRule } from '@miniflare/shared';
import { Options } from '@miniflare/shared';
import { Plugin } from '@miniflare/shared';
import { PluginContext } from '@miniflare/shared';
import { PluginSignatures } from '@miniflare/shared';
import { ProcessedModuleRule } from '@miniflare/shared';
import { ReadableStream as ReadableStream_2 } from 'stream/web';
import { Request as Request_3 } from 'undici';
import { RequestCache as RequestCache_2 } from 'undici';
import { RequestCredentials as RequestCredentials_2 } from 'undici';
import { RequestDestination as RequestDestination_2 } from 'undici';
import { RequestInfo as RequestInfo_3 } from 'undici';
import { RequestInit as RequestInit_3 } from 'undici';
import { RequestMode as RequestMode_2 } from 'undici';
import { RequestRedirect as RequestRedirect_2 } from 'undici';
import { Response as Response_3 } from 'undici';
import { ResponseInit as ResponseInit_3 } from 'undici';
import { ResponseRedirectStatus } from 'undici';
import { ResponseType as ResponseType_2 } from 'undici';
import { ScriptRunner } from '@miniflare/shared';
import { SetupResult } from '@miniflare/shared';
import { Storage } from '@miniflare/shared';
import { StorageFactory } from '@miniflare/shared';
import { TextDecoder as TextDecoder_3 } from 'util';
import { ThrowingEventTarget } from '@miniflare/shared';
import { TypedEventListener } from '@miniflare/shared';
import { TypedEventTarget } from '@miniflare/shared';
import { URL as URL_2 } from 'url';
import { ValueOf } from '@miniflare/shared';
import { webcrypto } from 'crypto';
import type { WebSocket as WebSocket_2 } from '@miniflare/web-sockets';
import { WranglerConfig } from '@miniflare/shared';

export declare type ArrayBufferViewConstructor = typeof Int8Array | typeof Uint8Array | typeof Uint8ClampedArray | typeof Int16Array | typeof Uint16Array | typeof Int32Array | typeof Uint32Array | typeof Float32Array | typeof Float64Array | typeof DataView;

export declare interface BasicImageTransformations {
    width?: number;
    height?: number;
    fit?: "scale-down" | "contain" | "cover" | "crop" | "pad";
    gravity?: "left" | "right" | "top" | "bottom" | "center" | BasicImageTransformationsGravityCoordinates;
    background?: string;
    rotate?: 0 | 90 | 180 | 270 | 360;
}

export declare interface BasicImageTransformationsGravityCoordinates {
    x: number;
    y: number;
}

export declare interface BindingsOptions {
    envPath?: boolean | string;
    bindings?: Record<string, any>;
    globals?: Record<string, any>;
    wasmBindings?: Record<string, string>;
}

export declare class BindingsPlugin extends Plugin<BindingsOptions> implements BindingsOptions {
    envPath?: boolean | string;
    [kWranglerBindings]?: Record<string, any>;
    bindings?: Record<string, any>;
    globals?: Record<string, any>;
    wasmBindings?: Record<string, string>;
    constructor(ctx: PluginContext, options?: BindingsOptions);
    setup(): Promise<SetupResult>;
}

declare class Body_2<Inner extends Request_3 | Response_3> {
    #private;
    [kInner]: Inner;
    [kInputGated]: boolean;
    [kFormDataFiles]: boolean;
    constructor(inner: Inner);
    [inspect](): Inner;
    get headers(): Headers_2;
    get body(): ReadableStream_2 | null;
    get bodyUsed(): boolean;
    arrayBuffer(): Promise<ArrayBuffer>;
    blob(): Promise<Blob_2>;
    formData(): Promise<FormData_2>;
    json<T>(): Promise<T>;
    text(): Promise<string>;
}
export { Body_2 as Body }

export declare class BuildError extends MiniflareError<number> {
}

export declare interface BuildOptions {
    buildCommand?: string;
    buildBasePath?: string;
    buildWatchPaths?: string[];
}

export declare class BuildPlugin extends Plugin<BuildOptions> implements BuildOptions {
    buildCommand?: string;
    buildBasePath?: string;
    buildWatchPaths?: string[];
    constructor(ctx: PluginContext, options?: BuildOptions);
    beforeSetup(): Awaitable<BeforeSetupResult>;
}

export declare interface CoreOptions {
    script?: string;
    scriptPath?: string;
    rootPath?: string;
    packagePath?: boolean | string;
    wranglerConfigPath?: boolean | string;
    wranglerConfigEnv?: string;
    modules?: boolean;
    modulesRules?: ModuleRule[];
    compatibilityDate?: string;
    compatibilityFlags?: CompatibilityFlag[];
    upstream?: string;
    watch?: boolean;
    debug?: boolean;
    verbose?: boolean;
    updateCheck?: boolean;
    mounts?: Record<string, string>;
}

export declare class CorePlugin extends Plugin<CoreOptions> implements CoreOptions {
    #private;
    script?: string;
    scriptPath?: string;
    wranglerConfigPath?: boolean | string;
    wranglerConfigEnv?: string;
    packagePath?: boolean | string;
    modules?: boolean;
    modulesRules?: ModuleRule[];
    compatibilityDate?: string;
    compatibilityFlags?: CompatibilityFlag[];
    upstream?: string;
    watch?: boolean;
    debug?: boolean;
    verbose?: boolean;
    updateCheck?: boolean;
    rootPath?: string;
    mounts?: Record<string, string>;
    readonly processedModuleRules: ProcessedModuleRule[];
    constructor(ctx: PluginContext, options?: CoreOptions);
    setup(): Promise<SetupResult>;
}

export declare type CorePluginSignatures = PluginSignatures & {
    CorePlugin: typeof CorePlugin;
};

export declare function createCompatFetch(compat: Compatibility, inner?: typeof fetch_2): typeof fetch_2;

declare const crypto_2: typeof webcrypto;
export { crypto_2 as crypto }

/* Excluded from this release type: _deepEqual */

export declare const DOM_EXCEPTION_NAMES: {
    IndexSizeError: number;
    DOMStringSizeError: number;
    HierarchyRequestError: number;
    WrongDocumentError: number;
    InvalidCharacterError: number;
    NoDataAllowedError: number;
    NoModificationAllowedError: number;
    NotFoundError: number;
    NotSupportedError: number;
    InUseAttributeError: number;
    InvalidStateError: number;
    SyntaxError: number;
    InvalidModificationError: number;
    NamespaceError: number;
    InvalidAccessError: number;
    ValidationError: number;
    TypeMismatchError: number;
    SecurityError: number;
    NetworkError: number;
    AbortError: number;
    URLMismatchError: number;
    QuotaExceededError: number;
    TimeoutError: number;
    InvalidNodeTypeError: number;
    DataCloneError: number;
};

declare class DOMException_2 extends Error {
    readonly name: keyof typeof DOM_EXCEPTION_NAMES | string;
    static readonly INDEX_SIZE_ERR = 1;
    static readonly DOMSTRING_SIZE_ERR = 2;
    static readonly HIERARCHY_REQUEST_ERR = 3;
    static readonly WRONG_DOCUMENT_ERR = 4;
    static readonly INVALID_CHARACTER_ERR = 5;
    static readonly NO_DATA_ALLOWED_ERR = 6;
    static readonly NO_MODIFICATION_ALLOWED_ERR = 7;
    static readonly NOT_FOUND_ERR = 8;
    static readonly NOT_SUPPORTED_ERR = 9;
    static readonly INUSE_ATTRIBUTE_ERR = 10;
    static readonly INVALID_STATE_ERR = 11;
    static readonly SYNTAX_ERR = 12;
    static readonly INVALID_MODIFICATION_ERR = 13;
    static readonly NAMESPACE_ERR = 14;
    static readonly INVALID_ACCESS_ERR = 15;
    static readonly VALIDATION_ERR = 16;
    static readonly TYPE_MISMATCH_ERR = 17;
    static readonly SECURITY_ERR = 18;
    static readonly NETWORK_ERR = 19;
    static readonly ABORT_ERR = 20;
    static readonly URL_MISMATCH_ERR = 21;
    static readonly QUOTA_EXCEEDED_ERR = 22;
    static readonly TIMEOUT_ERR = 23;
    static readonly INVALID_NODE_TYPE_ERR = 24;
    static readonly DATA_CLONE_ERR = 25;
    constructor(message?: string, name?: keyof typeof DOM_EXCEPTION_NAMES | string);
    get code(): number;
}
export { DOMException_2 as DOMException }

export declare class ExecutionContext {
    #private;
    constructor(event: FetchEvent_2 | ScheduledEvent);
    passThroughOnException(): void;
    waitUntil(promise: Awaitable<any>): void;
}

declare function fetch_2(input: RequestInfo_2, init?: RequestInit_2): Promise<Response_2>;
export { fetch_2 as fetch }

export declare class FetchError extends MiniflareError<FetchErrorCode> {
}

export declare type FetchErrorCode = "ERR_RESPONSE_TYPE" | "ERR_NO_UPSTREAM" | "ERR_NO_HANDLER" | "ERR_NO_RESPONSE";

declare class FetchEvent_2 extends Event {
    readonly request: Request_2;
    [kResponse]?: Promise<Response_2 | Response_3>;
    [kPassThrough]: boolean;
    readonly [kWaitUntil_2]: Promise<unknown>[];
    [kSent]: boolean;
    constructor(type: "fetch", init: {
        request: Request_2;
    });
    respondWith(response: Awaitable<Response_2 | Response_3>): void;
    passThroughOnException(): void;
    waitUntil(promise: Awaitable<any>): void;
}
export { FetchEvent_2 as FetchEvent }

export declare type HRTime = [seconds: number, nanoseconds: number];

export declare interface IncomingRequestCfProperties {
    asn: number;
    botManagement?: IncomingRequestCfPropertiesBotManagement;
    city?: string;
    clientTcpRtt: number;
    clientTrustScore?: number;
    colo: string;
    continent?: string;
    country: string;
    httpProtocol: string;
    latitude?: string;
    longitude?: string;
    metroCode?: string;
    postalCode?: string;
    region?: string;
    regionCode?: string;
    requestPriority: string;
    timezone?: string;
    tlsVersion: string;
    tlsCipher: string;
    tlsClientAuth: IncomingRequestCfPropertiesTLSClientAuth;
}

export declare interface IncomingRequestCfPropertiesBotManagement {
    score: number;
    staticResource: boolean;
    verifiedBot: boolean;
}

export declare interface IncomingRequestCfPropertiesTLSClientAuth {
    certIssuerDNLegacy: string;
    certIssuerDN: string;
    certPresented: "0" | "1";
    certSubjectDNLegacy: string;
    certSubjectDN: string;
    certNotBefore: string;
    certNotAfter: string;
    certSerial: string;
    certFingerprintSHA1: string;
    certVerified: string;
}

export declare function inputGatedSetInterval<Args extends any[]>(callback: (...args: Args) => void, ms?: number, ...args: Args): NodeJS.Timer;

export declare function inputGatedSetTimeout<Args extends any[]>(callback: (...args: Args) => void, ms?: number, ...args: Args): NodeJS.Timeout;

declare const inspect: unique symbol;

export declare const kAddModuleFetchListener: unique symbol;

export declare const kAddModuleScheduledListener: unique symbol;

export declare const kDispatchFetch: unique symbol;

export declare const kDispatchScheduled: unique symbol;

export declare const kDispose: unique symbol;

declare const kFormDataFiles: unique symbol;

declare const kInner: unique symbol;

declare const kInputGated: unique symbol;

declare const kPassThrough: unique symbol;

declare const kResponse: unique symbol;

declare const kSent: unique symbol;

declare const kWaitUntil: unique symbol;

declare const kWaitUntil_2: unique symbol;

declare const kWranglerBindings: unique symbol;

export declare function logResponse(log: Log, { start, method, url, status, waitUntil, }: {
    start: HRTime;
    method: string;
    url: string;
    status?: number;
    waitUntil?: Promise<any[]>;
}): Promise<void>;

export declare class MiniflareCore<Plugins extends CorePluginSignatures> extends TypedEventTarget<MiniflareCoreEventMap<Plugins>> {
    #private;
    constructor(plugins: Plugins, ctx: MiniflareCoreContext, options?: MiniflareCoreOptions<Plugins>);
    get log(): Log;
    reload(): Promise<void>;
    setOptions(options: MiniflareCoreOptions<Plugins>): Promise<void>;
    getPluginStorage(name: keyof Plugins): StorageFactory;
    getPlugins(): Promise<PluginInstances<Plugins>>;
    getGlobalScope(): Promise<Context>;
    getBindings(): Promise<Context>;
    getModuleExports(): Promise<Context>;
    getMount(name: string): Promise<MiniflareCore<Plugins>>;
    dispatchFetch<WaitUntil extends any[] = unknown[]>(input: RequestInfo_2, init?: RequestInit_2): Promise<Response_2<WaitUntil>>;
    dispatchScheduled<WaitUntil extends any[] = unknown[]>(scheduledTime?: number, cron?: string): Promise<WaitUntil>;
    dispose(): Promise<void>;
}

export declare interface MiniflareCoreContext {
    log: Log;
    storageFactory: StorageFactory;
    scriptRunner?: ScriptRunner;
    scriptRequired?: boolean;
    scriptRunForModuleExports?: boolean;
}

export declare class MiniflareCoreError extends MiniflareError<MiniflareCoreErrorCode> {
}

export declare type MiniflareCoreErrorCode = "ERR_NO_SCRIPT" | "ERR_MOUNT_NO_NAME" | "ERR_MOUNT_NESTED" | "ERR_MOUNT";

export declare type MiniflareCoreEventMap<Plugins extends PluginSignatures> = {
    reload: ReloadEvent<Plugins>;
};

export declare type MiniflareCoreOptions<Plugins extends CorePluginSignatures> = Omit<Options<Plugins>, "mounts"> & {
    mounts?: Record<string, string | Omit<Options<Plugins>, "mounts">>;
};

export declare type ModuleFetchListener = (request: Request_2, env: Context, ctx: ExecutionContext) => Response_2 | Promise<Response_2>;

export declare type ModuleScheduledListener = (controller: ScheduledController, env: Context, ctx: ExecutionContext) => any;

export declare type PluginInstances<Plugins extends PluginSignatures> = {
    [K in keyof Plugins]: InstanceType<Plugins[K]>;
};

export declare class PluginStorageFactory implements StorageFactory {
    private readonly inner;
    private readonly defaultPersistRoot;
    private readonly pluginName;
    constructor(inner: StorageFactory, pluginName: string, defaultPersistRoot?: string);
    storage(namespace: string, persist?: boolean | string): Awaitable<Storage>;
    dispose(): Awaitable<void>;
}

export declare function populateBuildConfig(config: WranglerConfig, configDir: string, configEnv?: string): void;

declare class PromiseRejectionEvent_2 extends Event {
    readonly promise: Promise<any>;
    readonly reason?: any;
    constructor(type: "unhandledrejection" | "rejectionhandled", init: {
        promise: Promise<any>;
        reason?: any;
    });
}
export { PromiseRejectionEvent_2 as PromiseRejectionEvent }

export declare class ReloadEvent<Plugins extends PluginSignatures> extends Event {
    readonly plugins: PluginInstances<Plugins>;
    readonly initial: boolean;
    constructor(plugins: PluginInstances<Plugins>, initial: boolean);
}

declare class Request_2 extends Body_2<Request_3> {
    #private;
    constructor(input: RequestInfo_2, init?: RequestInit_2);
    clone(): Request_2;
    get cf(): IncomingRequestCfProperties | RequestInitCfProperties | undefined;
    get cache(): RequestCache_2;
    get credentials(): RequestCredentials_2;
    get destination(): RequestDestination_2;
    get integrity(): string;
    get method(): string;
    get mode(): RequestMode_2;
    get redirect(): RequestRedirect_2;
    get referrerPolicy(): string;
    get url(): string;
    get keepalive(): boolean;
    get signal(): AbortSignal;
}
export { Request_2 as Request }

declare type RequestInfo_2 = RequestInfo_3 | Request_2;
export { RequestInfo_2 as RequestInfo }

declare interface RequestInit_2 extends RequestInit_3 {
    readonly cf?: IncomingRequestCfProperties | RequestInitCfProperties;
}
export { RequestInit_2 as RequestInit }

export declare interface RequestInitCfProperties {
    cacheEverything?: boolean;
    cacheKey?: string;
    cacheTtl?: number;
    cacheTtlByStatus?: Record<string, number>;
    scrapeShield?: boolean;
    apps?: boolean;
    image?: RequestInitCfPropertiesImage;
    minify?: RequestInitCfPropertiesImageMinify;
    mirage?: boolean;
    resolveOverride?: string;
}

export declare interface RequestInitCfPropertiesImage extends BasicImageTransformations {
    dpr?: number;
    quality?: number;
    format?: "avif" | "webp" | "json";
    metadata?: "keep" | "copyright" | "none";
    draw?: RequestInitCfPropertiesImageDraw[];
}

export declare interface RequestInitCfPropertiesImageDraw extends BasicImageTransformations {
    url: string;
    opacity?: number;
    repeat?: true | "x" | "y";
    top?: number;
    left?: number;
    bottom?: number;
    right?: number;
}

export declare interface RequestInitCfPropertiesImageMinify {
    javascript?: boolean;
    css?: boolean;
    html?: boolean;
}

declare class Response_2<WaitUntil extends any[] = unknown[]> extends Body_2<Response_3> {
    #private;
    static redirect(url: string | URL_2, status: ResponseRedirectStatus): Response_2;
    [kWaitUntil]?: Promise<WaitUntil>;
    constructor(body?: BodyInit_2, init?: ResponseInit_2 | Response_2 | Response_3);
    clone(): Response_2;
    get encodeBody(): "auto" | "manual";
    get webSocket(): WebSocket_2 | undefined;
    waitUntil(): Promise<WaitUntil>;
    get status(): number;
    get ok(): boolean;
    get statusText(): string;
    get type(): ResponseType_2;
    get url(): string;
    get redirected(): boolean;
}
export { Response_2 as Response }

declare interface ResponseInit_2 extends ResponseInit_3 {
    readonly encodeBody?: "auto" | "manual";
    readonly webSocket?: WebSocket_2;
}
export { ResponseInit_2 as ResponseInit }

export declare class ScheduledController {
    readonly scheduledTime: number;
    readonly cron: string;
    constructor(scheduledTime: number, cron: string);
}

export declare class ScheduledEvent extends Event {
    readonly scheduledTime: number;
    readonly cron: string;
    readonly [kWaitUntil_2]: Promise<unknown>[];
    constructor(type: "scheduled", init: {
        scheduledTime: number;
        cron: string;
    });
    waitUntil(promise: Promise<any>): void;
}

declare class ServiceWorkerGlobalScope_2 extends WorkerGlobalScope_2 {
    #private;
    readonly global: this;
    readonly self: this;
    constructor(log: Log, globals: Context, bindings: Context, modules?: boolean);
    addEventListener: <Type extends keyof WorkerGlobalScopeEventMap_2>(type: Type, listener: TypedEventListener<WorkerGlobalScopeEventMap_2[Type]> | null, options?: boolean | AddEventListenerOptions | undefined) => void;
    removeEventListener: <Type extends keyof WorkerGlobalScopeEventMap_2>(type: Type, listener: TypedEventListener<WorkerGlobalScopeEventMap_2[Type]> | null, options?: boolean | EventListenerOptions | undefined) => void;
    dispatchEvent: (event: ValueOf<WorkerGlobalScopeEventMap_2>) => boolean;
    [kAddModuleFetchListener](listener: ModuleFetchListener): void;
    [kAddModuleScheduledListener](listener: ModuleScheduledListener): void;
    [kDispatchFetch]<WaitUntil extends any[] = unknown[]>(request: Request_2, proxy?: boolean): Promise<Response_2<WaitUntil>>;
    [kDispatchScheduled]<WaitUntil extends any[] = any[]>(scheduledTime?: number, cron?: string): Promise<WaitUntil>;
    [kDispose](): void;
}
export { ServiceWorkerGlobalScope_2 as ServiceWorkerGlobalScope }

declare class TextDecoder_2 extends TextDecoder_3 {
    constructor(encoding?: string, options?: {
        fatal?: boolean;
        ignoreBOM?: boolean;
    });
}
export { TextDecoder_2 as TextDecoder }

export declare function withImmutableHeaders(req: Request_2): Request_2;

export declare function withInputGating<Inner extends Body_2<Request_3 | Response_3>>(body: Inner): Inner;

export declare function withStringFormDataFiles<Inner extends Body_2<Request_3 | Response_3>>(body: Inner): Inner;

export declare function withWaitUntil<WaitUntil extends any[]>(res: Response_2 | Response_3, waitUntil: Promise<WaitUntil>): Response_2<WaitUntil>;

declare class WorkerGlobalScope_2 extends ThrowingEventTarget<WorkerGlobalScopeEventMap_2> {
}
export { WorkerGlobalScope_2 as WorkerGlobalScope }

declare type WorkerGlobalScopeEventMap_2 = {
    fetch: FetchEvent_2;
    scheduled: ScheduledEvent;
    unhandledrejection: PromiseRejectionEvent_2;
    rejectionhandled: PromiseRejectionEvent_2;
};
export { WorkerGlobalScopeEventMap_2 as WorkerGlobalScopeEventMap }

export { }
