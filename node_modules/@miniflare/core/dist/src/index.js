var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __decorateClass = (decorators, target, key, kind) => {
  var result = kind > 1 ? void 0 : kind ? __getOwnPropDesc(target, key) : target;
  for (var i = decorators.length - 1, decorator; i >= 0; i--)
    if (decorator = decorators[i])
      result = (kind ? decorator(target, key, result) : decorator(result)) || result;
  if (kind && result)
    __defProp(target, key, result);
  return result;
};
var __publicField = (obj, key, value) => {
  __defNormalProp(obj, typeof key !== "symbol" ? key + "" : key, value);
  return value;
};

// packages/core/src/index.ts
import fs3 from "fs/promises";
import path6 from "path";
import { URL as URL3 } from "url";
import {
  Compatibility as Compatibility2,
  Log as Log3,
  MiniflareError as MiniflareError3,
  Mutex,
  TypedEventTarget,
  addAll,
  logOptions
} from "@miniflare/shared";

// node_modules/dequal/lite/index.mjs
var has = Object.prototype.hasOwnProperty;
function dequal(foo, bar) {
  var ctor, len;
  if (foo === bar)
    return true;
  if (foo && bar && (ctor = foo.constructor) === bar.constructor) {
    if (ctor === Date)
      return foo.getTime() === bar.getTime();
    if (ctor === RegExp)
      return foo.toString() === bar.toString();
    if (ctor === Array) {
      if ((len = foo.length) === bar.length) {
        while (len-- && dequal(foo[len], bar[len]))
          ;
      }
      return len === -1;
    }
    if (!ctor || typeof foo === "object") {
      len = 0;
      for (ctor in foo) {
        if (has.call(foo, ctor) && ++len && !has.call(bar, ctor))
          return false;
        if (!(ctor in bar) || !dequal(foo[ctor], bar[ctor]))
          return false;
      }
      return Object.keys(bar).length === len;
    }
  }
  return foo !== foo && bar !== bar;
}

// packages/core/src/index.ts
import { dim } from "kleur/colors";

// packages/core/src/helpers.ts
import path from "path";
function pathsToString(set) {
  return [...set].map((filePath) => path.relative("", filePath)).sort().join(", ");
}
function formatSize(bytes) {
  if (bytes >= 524288)
    return `${(bytes / 1048576).toFixed(2)}MiB`;
  if (bytes >= 512)
    return `${(bytes / 1024).toFixed(2)}KiB`;
  return `${bytes}B`;
}

// packages/core/src/plugins/bindings.ts
import fs from "fs/promises";
import path2 from "path";
import {
  Option,
  OptionType,
  Plugin
} from "@miniflare/shared";
import dotenv from "dotenv";
var kWranglerBindings = Symbol("kWranglerBindings");
var _a;
var BindingsPlugin = class extends Plugin {
  envPath;
  [_a = kWranglerBindings];
  bindings;
  globals;
  wasmBindings;
  constructor(ctx, options) {
    super(ctx);
    this.assignOptions(options);
  }
  async setup() {
    const bindings = {};
    const watch = [];
    Object.assign(bindings, this[kWranglerBindings]);
    const envPath = this.envPath === true ? path2.join(this.ctx.rootPath, ".env") : this.envPath;
    if (envPath) {
      try {
        Object.assign(bindings, dotenv.parse(await fs.readFile(envPath, "utf8")));
      } catch (e) {
        if (!(e.code === "ENOENT" && this.envPath === true))
          throw e;
      }
      watch.push(envPath);
    }
    if (this.wasmBindings) {
      for (const [name, wasmPath] of Object.entries(this.wasmBindings)) {
        bindings[name] = new WebAssembly.Module(await fs.readFile(wasmPath));
        watch.push(wasmPath);
      }
    }
    Object.assign(bindings, this.bindings);
    return { globals: this.globals, bindings, watch };
  }
};
__decorateClass([
  Option({
    type: OptionType.STRING,
    name: "env",
    alias: "e",
    description: "Path to .env file",
    logValue(value) {
      if (value === true)
        return ".env";
      if (value === false)
        return void 0;
      return path2.relative("", value);
    },
    fromWrangler: ({ miniflare }) => miniflare?.env_path
  })
], BindingsPlugin.prototype, "envPath", 2);
__decorateClass([
  Option({
    type: OptionType.OBJECT,
    logName: "Wrangler Variables",
    fromWrangler: ({ vars }) => {
      if (!vars)
        return;
      return Object.fromEntries(Object.entries(vars).map(([key, value]) => [key, String(value)]));
    }
  })
], BindingsPlugin.prototype, _a, 2);
__decorateClass([
  Option({
    type: OptionType.OBJECT,
    alias: "b",
    description: "Binds variable/secret to environment",
    logName: "Custom Bindings"
  })
], BindingsPlugin.prototype, "bindings", 2);
__decorateClass([
  Option({
    type: OptionType.OBJECT,
    description: "Binds variable/secret to global scope",
    logName: "Custom Globals",
    fromWrangler: ({ miniflare }) => miniflare?.globals
  })
], BindingsPlugin.prototype, "globals", 2);
__decorateClass([
  Option({
    type: OptionType.OBJECT,
    typeFormat: "NAME=PATH",
    name: "wasm",
    description: "WASM module to bind",
    logName: "WASM Bindings",
    fromWrangler: ({ wasm_modules }) => wasm_modules
  })
], BindingsPlugin.prototype, "wasmBindings", 2);

// packages/core/src/plugins/build.ts
import assert from "assert";
import childProcess from "child_process";
import path3 from "path";
import { fileURLToPath } from "url";
import {
  MiniflareError,
  Option as Option2,
  OptionType as OptionType2,
  Plugin as Plugin2
} from "@miniflare/shared";
var BuildError = class extends MiniflareError {
};
var BuildPlugin = class extends Plugin2 {
  buildCommand;
  buildBasePath;
  buildWatchPaths;
  constructor(ctx, options) {
    super(ctx);
    this.assignOptions(options);
  }
  beforeSetup() {
    const buildCommand = this.buildCommand;
    if (!buildCommand)
      return {};
    return new Promise((resolve, reject) => {
      const build = childProcess.spawn(buildCommand, {
        cwd: this.buildBasePath,
        shell: true,
        stdio: "inherit",
        env: { ...process.env, MINIFLARE: "1" }
      });
      build.on("exit", (exitCode) => {
        if (exitCode !== 0) {
          const error = new BuildError(exitCode ?? 0, `Build failed with exit code ${exitCode}`);
          return reject(error);
        }
        this.ctx.log.info("Build succeeded");
        resolve({ watch: this.buildWatchPaths });
      });
    });
  }
};
__decorateClass([
  Option2({
    type: OptionType2.STRING,
    alias: "B",
    description: "Command to build project",
    fromWrangler: ({ build }) => build?.command
  })
], BuildPlugin.prototype, "buildCommand", 2);
__decorateClass([
  Option2({
    type: OptionType2.STRING,
    description: "Working directory for build command",
    fromWrangler: ({ build }) => build?.cwd
  })
], BuildPlugin.prototype, "buildBasePath", 2);
__decorateClass([
  Option2({
    type: OptionType2.ARRAY,
    description: "Directory to watch for rebuilding on changes",
    fromWrangler: ({ build }) => {
      if (build?.watch_dir)
        return [build.watch_dir];
      if (build?.command)
        return ["src"];
    }
  })
], BuildPlugin.prototype, "buildWatchPaths", 2);
function populateBuildConfig(config, configDir, configEnv) {
  if (config.build || config.type !== "webpack" && config.type !== "rust") {
    return;
  }
  config.build = { cwd: configDir, upload: { dir: "" } };
  assert(config.build.upload);
  const env = configEnv ? ` --env ${configEnv}` : "";
  if (config.type === "webpack") {
    config.build.command = `wrangler build${env}`;
    config.build.upload.main = path3.join("worker", "script.js");
  } else if (config.type === "rust") {
    const __filename = fileURLToPath(import.meta.url);
    const __dirname = path3.dirname(__filename);
    const rustScript = path3.join(__dirname, "plugins", "rust.js");
    config.build.command = `wrangler build${env} && ${process.execPath} ${rustScript}`;
    config.build.upload.main = path3.join("worker", "generated", "script.js");
    config.wasm_modules ??= {};
    config.wasm_modules.wasm = path3.join(configDir, "worker", "generated", "script.wasm");
  }
}

// packages/core/src/plugins/core.ts
import { Blob } from "buffer";
import fs2 from "fs/promises";
import path4 from "path";
import {
  ByteLengthQueuingStrategy,
  CountQueuingStrategy,
  ReadableByteStreamController,
  ReadableStream as ReadableStream2,
  ReadableStreamBYOBReader as ReadableStreamBYOBReader2,
  ReadableStreamBYOBRequest,
  ReadableStreamDefaultController,
  ReadableStreamDefaultReader,
  TransformStream,
  TransformStreamDefaultController,
  WritableStream,
  WritableStreamDefaultController,
  WritableStreamDefaultWriter
} from "stream/web";
import { URL as URL2, URLSearchParams } from "url";
import { TextEncoder } from "util";
import {
  Option as Option3,
  OptionType as OptionType3,
  Plugin as Plugin3,
  STRING_SCRIPT_PATH,
  globsToMatcher
} from "@miniflare/shared";
import { File as File2, FormData as FormData2, Headers as Headers2 } from "undici";

// packages/core/src/standards/crypto.ts
import { createHash, webcrypto } from "crypto";
import { viewToBuffer } from "@miniflare/shared";
function digest(algorithm, data) {
  const name = typeof algorithm === "string" ? algorithm : algorithm?.name;
  if (name?.toLowerCase() == "md5") {
    if (data instanceof ArrayBuffer)
      data = new Uint8Array(data);
    const hash = createHash("md5").update(data);
    return Promise.resolve(viewToBuffer(hash.digest()));
  }
  return webcrypto.subtle.digest(algorithm, data);
}
var subtle = new Proxy(webcrypto.subtle, {
  get(target, propertyKey, receiver) {
    if (propertyKey === "digest")
      return digest;
    return Reflect.get(target, propertyKey, receiver);
  }
});
var crypto = new Proxy(webcrypto, {
  get(target, propertyKey, receiver) {
    if (propertyKey === "subtle")
      return subtle;
    return Reflect.get(target, propertyKey, receiver);
  }
});

// packages/core/src/standards/domexception.ts
var DOM_EXCEPTION_NAMES = {
  IndexSizeError: 1,
  DOMStringSizeError: 2,
  HierarchyRequestError: 3,
  WrongDocumentError: 4,
  InvalidCharacterError: 5,
  NoDataAllowedError: 6,
  NoModificationAllowedError: 7,
  NotFoundError: 8,
  NotSupportedError: 9,
  InUseAttributeError: 10,
  InvalidStateError: 11,
  SyntaxError: 12,
  InvalidModificationError: 13,
  NamespaceError: 14,
  InvalidAccessError: 15,
  ValidationError: 16,
  TypeMismatchError: 17,
  SecurityError: 18,
  NetworkError: 19,
  AbortError: 20,
  URLMismatchError: 21,
  QuotaExceededError: 22,
  TimeoutError: 23,
  InvalidNodeTypeError: 24,
  DataCloneError: 25
};
var DOMException = class extends Error {
  constructor(message, name = "Error") {
    super(message);
    this.name = name;
  }
  get code() {
    return DOM_EXCEPTION_NAMES[this.name] ?? 0;
  }
};
__publicField(DOMException, "INDEX_SIZE_ERR", 1);
__publicField(DOMException, "DOMSTRING_SIZE_ERR", 2);
__publicField(DOMException, "HIERARCHY_REQUEST_ERR", 3);
__publicField(DOMException, "WRONG_DOCUMENT_ERR", 4);
__publicField(DOMException, "INVALID_CHARACTER_ERR", 5);
__publicField(DOMException, "NO_DATA_ALLOWED_ERR", 6);
__publicField(DOMException, "NO_MODIFICATION_ALLOWED_ERR", 7);
__publicField(DOMException, "NOT_FOUND_ERR", 8);
__publicField(DOMException, "NOT_SUPPORTED_ERR", 9);
__publicField(DOMException, "INUSE_ATTRIBUTE_ERR", 10);
__publicField(DOMException, "INVALID_STATE_ERR", 11);
__publicField(DOMException, "SYNTAX_ERR", 12);
__publicField(DOMException, "INVALID_MODIFICATION_ERR", 13);
__publicField(DOMException, "NAMESPACE_ERR", 14);
__publicField(DOMException, "INVALID_ACCESS_ERR", 15);
__publicField(DOMException, "VALIDATION_ERR", 16);
__publicField(DOMException, "TYPE_MISMATCH_ERR", 17);
__publicField(DOMException, "SECURITY_ERR", 18);
__publicField(DOMException, "NETWORK_ERR", 19);
__publicField(DOMException, "ABORT_ERR", 20);
__publicField(DOMException, "URL_MISMATCH_ERR", 21);
__publicField(DOMException, "QUOTA_EXCEEDED_ERR", 22);
__publicField(DOMException, "TIMEOUT_ERR", 23);
__publicField(DOMException, "INVALID_NODE_TYPE_ERR", 24);
__publicField(DOMException, "DATA_CLONE_ERR", 25);

// packages/core/src/standards/encoding.ts
import { TextDecoder as BaseTextDecoder } from "util";
var TextDecoder = class extends BaseTextDecoder {
  constructor(encoding, options) {
    const validEncoding = encoding === void 0 || encoding === "utf-8" || encoding === "utf8" || encoding === "unicode-1-1-utf-8";
    if (!validEncoding) {
      throw new RangeError("TextDecoder only supports utf-8 encoding");
    }
    super(encoding, options);
  }
};

// packages/core/src/standards/event.ts
import {
  MiniflareError as MiniflareError2,
  ThrowingEventTarget
} from "@miniflare/shared";
import { Response as BaseResponse2, fetch as fetch2 } from "undici";

// packages/core/src/standards/http.ts
import assert2 from "assert";
import http from "http";
import { ReadableStream } from "stream/web";
import { URL } from "url";
import {
  InputGatedTransformStream,
  nonCircularClone,
  waitForOpenInputGate,
  waitForOpenOutputGate
} from "@miniflare/shared";
import { blue, bold, green, grey, red, yellow } from "kleur/colors";
import { splitCookiesString } from "set-cookie-parser";
import {
  Request as BaseRequest,
  Response as BaseResponse,
  File,
  FormData,
  Headers,
  fetch as baseFetch
} from "undici";
import fetchSymbols from "undici/lib/fetch/symbols.js";
var inspect = Symbol.for("nodejs.util.inspect.custom");
var nonEnumerable = Object.create(null);
nonEnumerable.enumerable = false;
function makeEnumerable(prototype, instance, keys) {
  for (const key of keys) {
    const descriptor = Object.getOwnPropertyDescriptor(prototype, key);
    descriptor.enumerable = true;
    Object.defineProperty(instance, key, descriptor);
  }
}
Headers.prototype.getAll = function(key) {
  if (key.toLowerCase() !== "set-cookie") {
    throw new TypeError('getAll() can only be used with the header name "Set-Cookie".');
  }
  const value = this.get("set-cookie");
  return value ? splitCookiesString(value) : [];
};
var kInner = Symbol("kInner");
var kInputGated = Symbol("kInputGated");
var kFormDataFiles = Symbol("kFormDataFiles");
var enumerableBodyKeys = ["body", "bodyUsed", "headers"];
var Body = class {
  [kInner];
  [kInputGated] = false;
  [kFormDataFiles] = true;
  #inputGatedBody;
  constructor(inner) {
    this[kInner] = inner;
    makeEnumerable(Body.prototype, this, enumerableBodyKeys);
    Object.defineProperty(this, kInner, nonEnumerable);
    Object.defineProperty(this, kInputGated, nonEnumerable);
    Object.defineProperty(this, kFormDataFiles, nonEnumerable);
  }
  [inspect]() {
    return this[kInner];
  }
  get headers() {
    return this[kInner].headers;
  }
  get body() {
    const body = this[kInner].body;
    if (!this[kInputGated] || body === null)
      return body;
    if (this.#inputGatedBody)
      return this.#inputGatedBody;
    assert2(body instanceof ReadableStream);
    let bodyStream = body;
    let bodyPiped = false;
    this.#inputGatedBody = new Proxy(bodyStream, {
      get(target, propertyKey, receiver) {
        if (!bodyPiped && (propertyKey === Symbol.asyncIterator || propertyKey === "getReader" || propertyKey === "pipeThrough" || propertyKey === "pipeTo" || propertyKey === "tee" || propertyKey === "values")) {
          bodyPiped = true;
          bodyStream = bodyStream.pipeThrough(new InputGatedTransformStream());
        }
        return Reflect.get(bodyStream, propertyKey, receiver);
      }
    });
    return this.#inputGatedBody;
  }
  get bodyUsed() {
    return this[kInner].bodyUsed;
  }
  async arrayBuffer() {
    const body = await this[kInner].arrayBuffer();
    this[kInputGated] && await waitForOpenInputGate();
    return body;
  }
  async blob() {
    const body = await this[kInner].blob();
    this[kInputGated] && await waitForOpenInputGate();
    return body;
  }
  async formData() {
    const headers = {};
    for (const [key, value] of this.headers)
      headers[key.toLowerCase()] = value;
    if (headers["content-type"] === void 0) {
      throw new TypeError("Parsing a Body as FormData requires a Content-Type header.");
    }
    const formData = new FormData();
    await new Promise(async (resolve) => {
      const Busboy = await import("busboy");
      const busboy = new Busboy.default({ headers });
      busboy.on("field", (name, value) => {
        formData.append(name, value);
      });
      busboy.on("file", (name, value, filename, encoding, type) => {
        const base64 = encoding.toLowerCase() === "base64";
        const chunks = [];
        let totalLength = 0;
        value.on("data", (chunk) => {
          if (base64)
            chunk = Buffer.from(chunk.toString(), "base64");
          chunks.push(chunk);
          totalLength += chunk.byteLength;
        });
        value.on("end", () => {
          if (this[kFormDataFiles]) {
            const file = new File(chunks, filename, { type });
            formData.append(name, file);
          } else {
            const text = Buffer.concat(chunks, totalLength).toString();
            formData.append(name, text);
          }
        });
      });
      busboy.on("finish", resolve);
      const body = this[kInner].body;
      if (body !== null)
        for await (const chunk of body)
          busboy.write(chunk);
      busboy.end();
    });
    this[kInputGated] && await waitForOpenInputGate();
    return formData;
  }
  async json() {
    const body = await this[kInner].json();
    this[kInputGated] && await waitForOpenInputGate();
    return body;
  }
  async text() {
    const body = await this[kInner].text();
    this[kInputGated] && await waitForOpenInputGate();
    return body;
  }
};
function withInputGating(body) {
  body[kInputGated] = true;
  return body;
}
function withStringFormDataFiles(body) {
  body[kFormDataFiles] = false;
  return body;
}
var enumerableRequestKeys = [
  "cf",
  "signal",
  "redirect",
  "url",
  "method"
];
var Request = class extends Body {
  #cf;
  constructor(input, init) {
    const cf = input instanceof Request ? input.#cf : init?.cf;
    if (input instanceof BaseRequest && !init) {
      super(input);
    } else {
      if (input instanceof Request)
        input = input[kInner];
      super(new BaseRequest(input, init));
    }
    this.#cf = cf ? nonCircularClone(cf) : void 0;
    makeEnumerable(Request.prototype, this, enumerableRequestKeys);
  }
  clone() {
    const innerClone = this[kInner].clone();
    const clone = new Request(innerClone);
    clone[kInputGated] = this[kInputGated];
    clone[kFormDataFiles] = this[kFormDataFiles];
    clone.#cf = this.cf ? nonCircularClone(this.cf) : void 0;
    return clone;
  }
  get cf() {
    return this.#cf;
  }
  get cache() {
    return this[kInner].cache;
  }
  get credentials() {
    return this[kInner].credentials;
  }
  get destination() {
    return this[kInner].destination;
  }
  get integrity() {
    return this[kInner].integrity;
  }
  get method() {
    return this[kInner].method;
  }
  get mode() {
    return this[kInner].mode;
  }
  get redirect() {
    return this[kInner].redirect;
  }
  get referrerPolicy() {
    return this[kInner].referrerPolicy;
  }
  get url() {
    return this[kInner].url;
  }
  get keepalive() {
    return this[kInner].keepalive;
  }
  get signal() {
    return this[kInner].signal;
  }
};
function withImmutableHeaders(req) {
  req.headers[fetchSymbols.kGuard] = "immutable";
  return req;
}
var kWaitUntil = Symbol("kWaitUntil");
var enumerableResponseKeys = [
  "encodeBody",
  "webSocket",
  "url",
  "redirected",
  "ok",
  "statusText",
  "status",
  "type"
];
var Response = class extends Body {
  static redirect(url, status) {
    const res = BaseResponse.redirect(url, status);
    return new Response(res.body, res);
  }
  #encodeBody;
  #status;
  #webSocket;
  [kWaitUntil];
  constructor(body, init) {
    let encodeBody;
    let status;
    let webSocket;
    if (init instanceof BaseResponse && body === init.body) {
      super(init);
    } else {
      if (init instanceof Response) {
        encodeBody = init.#encodeBody;
        init = init[kInner];
      } else if (!(init instanceof BaseResponse) && init) {
        encodeBody = init.encodeBody;
        if (init.webSocket) {
          if (init.status !== 101) {
            throw new RangeError("Responses with a WebSocket must have status code 101.");
          }
          status = init.status;
          webSocket = init.webSocket;
          init = { ...init, status: 200 };
        }
      }
      super(new BaseResponse(body, init));
    }
    encodeBody ??= "auto";
    if (encodeBody !== "auto" && encodeBody !== "manual") {
      throw new TypeError(`encodeBody: unexpected value: ${encodeBody}`);
    }
    this.#encodeBody = encodeBody;
    this.#status = status;
    this.#webSocket = webSocket;
    makeEnumerable(Response.prototype, this, enumerableResponseKeys);
    Object.defineProperty(this, kWaitUntil, nonEnumerable);
  }
  clone() {
    if (this.#webSocket) {
      throw new TypeError("Cannot clone a response to a WebSocket handshake.");
    }
    const innerClone = this[kInner].clone();
    const clone = new Response(innerClone.body, innerClone);
    clone[kInputGated] = this[kInputGated];
    clone[kFormDataFiles] = this[kFormDataFiles];
    clone.#encodeBody = this.#encodeBody;
    clone.#status = this.#status;
    clone[kWaitUntil] = this[kWaitUntil];
    return clone;
  }
  get encodeBody() {
    return this.#encodeBody;
  }
  get webSocket() {
    return this.#webSocket;
  }
  waitUntil() {
    return this[kWaitUntil] ?? Promise.resolve([]);
  }
  get status() {
    return this.#status ?? this[kInner].status;
  }
  get ok() {
    return this[kInner].ok;
  }
  get statusText() {
    return this[kInner].statusText;
  }
  get type() {
    return this[kInner].type;
  }
  get url() {
    return this[kInner].url;
  }
  get redirected() {
    return this[kInner].redirected;
  }
};
function withWaitUntil(res, waitUntil) {
  const resWaitUntil = res instanceof Response ? res : new Response(res.body, res);
  resWaitUntil[kWaitUntil] = waitUntil;
  return resWaitUntil;
}
async function fetch(input, init) {
  if (input instanceof Request)
    input = input[kInner];
  await waitForOpenOutputGate();
  const baseRes = await baseFetch(input, init);
  const res = new Response(baseRes.body, baseRes);
  await waitForOpenInputGate();
  return withInputGating(res);
}
function createCompatFetch(compat, inner = fetch) {
  const refusesUnknown = compat.isEnabled("fetch_refuses_unknown_protocols");
  const formDataFiles = compat.isEnabled("formdata_parser_supports_files");
  return async (input, init) => {
    const url = new URL(input instanceof Request || input instanceof BaseRequest ? input.url : input.toString());
    if (url.protocol !== "http:" && url.protocol !== "https:") {
      if (refusesUnknown) {
        throw new TypeError(`Fetch API cannot load: ${url.toString()}`);
      } else {
        if (init) {
          init = new Request(input, init);
        } else if (input instanceof BaseRequest) {
          init = new Request(input);
        } else if (input instanceof Request) {
          init = input;
        }
        url.protocol = "http:";
        input = url;
      }
    }
    let res = await inner(input, init);
    if (!formDataFiles)
      res = withStringFormDataFiles(res);
    return res;
  };
}
function millisFromHRTime([seconds, nanoseconds]) {
  return `${((seconds * 1e9 + nanoseconds) / 1e6).toFixed(2)}ms`;
}
function colourFromHTTPStatus(status) {
  if (200 <= status && status < 300)
    return green;
  if (400 <= status && status < 500)
    return yellow;
  if (500 <= status)
    return red;
  return blue;
}
async function logResponse(log, {
  start,
  method,
  url,
  status,
  waitUntil
}) {
  const responseTime = millisFromHRTime(process.hrtime(start));
  let waitUntilResponse;
  try {
    waitUntilResponse = await waitUntil;
  } catch (e) {
    waitUntilResponse = [""];
    log.error(e);
  }
  const waitUntilTime = millisFromHRTime(process.hrtime(start));
  log.log([
    `${bold(method)} ${url} `,
    status ? colourFromHTTPStatus(status)(`${bold(status)} ${http.STATUS_CODES[status]} `) : "",
    grey(`(${responseTime}`),
    waitUntilResponse?.length ? grey(`, waitUntil: ${waitUntilTime}`) : "",
    grey(")")
  ].join(""));
}

// packages/core/src/standards/event.ts
var FetchError = class extends MiniflareError2 {
};
var SUGGEST_HANDLER = 'calling addEventListener("fetch", ...)';
var SUGGEST_HANDLER_MODULES = "exporting a default object containing a `fetch` function property";
var SUGGEST_RES = "calling `event.respondWith()` with a `Response` or `Promise<Response>` in your handler";
var SUGGEST_RES_MODULES = "returning a `Response` in your handler";
var SUGGEST_GLOBAL_BINDING_MODULES = "Attempted to access binding using global in modules.\nYou must use the 2nd `env` parameter passed to exported handlers or Durable Object constructors.";
var kResponse = Symbol("kResponse");
var kPassThrough = Symbol("kPassThrough");
var kWaitUntil2 = Symbol("kWaitUntil");
var kSent = Symbol("kSent");
var FetchEvent = class extends Event {
  request;
  [kResponse];
  [kPassThrough] = false;
  [kWaitUntil2] = [];
  [kSent] = false;
  constructor(type, init) {
    super(type);
    this.request = init.request;
  }
  respondWith(response) {
    if (!(this instanceof FetchEvent)) {
      throw new TypeError("Illegal invocation");
    }
    if (this[kResponse]) {
      throw new DOMException("FetchEvent.respondWith() has already been called; it can only be called once.", "InvalidStateError");
    }
    if (this[kSent]) {
      throw new DOMException("Too late to call FetchEvent.respondWith(). It must be called synchronously in the event handler.", "InvalidStateError");
    }
    this.stopImmediatePropagation();
    this[kResponse] = Promise.resolve(response);
  }
  passThroughOnException() {
    if (!(this instanceof FetchEvent)) {
      throw new TypeError("Illegal invocation");
    }
    this[kPassThrough] = true;
  }
  waitUntil(promise) {
    if (!(this instanceof FetchEvent)) {
      throw new TypeError("Illegal invocation");
    }
    this[kWaitUntil2].push(Promise.resolve(promise));
  }
};
var ScheduledEvent = class extends Event {
  scheduledTime;
  cron;
  [kWaitUntil2] = [];
  constructor(type, init) {
    super(type);
    this.scheduledTime = init.scheduledTime;
    this.cron = init.cron;
  }
  waitUntil(promise) {
    if (!(this instanceof ScheduledEvent)) {
      throw new TypeError("Illegal invocation");
    }
    this[kWaitUntil2].push(promise);
  }
};
var ExecutionContext = class {
  #event;
  constructor(event) {
    this.#event = event;
  }
  passThroughOnException() {
    if (!(this instanceof ExecutionContext)) {
      throw new TypeError("Illegal invocation");
    }
    if (this.#event instanceof FetchEvent)
      this.#event.passThroughOnException();
  }
  waitUntil(promise) {
    if (!(this instanceof ExecutionContext)) {
      throw new TypeError("Illegal invocation");
    }
    this.#event.waitUntil(promise);
  }
};
var ScheduledController = class {
  constructor(scheduledTime, cron) {
    this.scheduledTime = scheduledTime;
    this.cron = cron;
  }
};
var kAddModuleFetchListener = Symbol("kAddModuleFetchListener");
var kAddModuleScheduledListener = Symbol("kAddModuleScheduledListener");
var kDispatchFetch = Symbol("kDispatchFetch");
var kDispatchScheduled = Symbol("kDispatchScheduled");
var kDispose = Symbol("kDispose");
var PromiseRejectionEvent = class extends Event {
  promise;
  reason;
  constructor(type, init) {
    super(type, { cancelable: true });
    this.promise = init.promise;
    this.reason = init.reason;
  }
};
var WorkerGlobalScope = class extends ThrowingEventTarget {
};
var ServiceWorkerGlobalScope = class extends WorkerGlobalScope {
  #log;
  #bindings;
  #modules;
  #calledAddFetchEventListener = false;
  #rejectionHandledListeners = new Set();
  #unhandledRejectionListeners = new Set();
  global = this;
  self = this;
  constructor(log, globals, bindings, modules) {
    super();
    this.#log = log;
    this.#bindings = bindings;
    this.#modules = modules;
    Object.assign(this, globals);
    if (modules) {
      for (const key of Object.keys(bindings)) {
        if (key === "__STATIC_CONTENT" || key === "__STATIC_CONTENT_MANIFEST") {
          break;
        }
        Object.defineProperty(this, key, {
          get() {
            throw new ReferenceError(`${key} is not defined.
${SUGGEST_GLOBAL_BINDING_MODULES}`);
          }
        });
      }
    } else {
      Object.assign(this, bindings);
    }
  }
  addEventListener = (type, listener, options) => {
    if (this.#modules) {
      throw new TypeError("Global addEventListener() cannot be used in modules. Instead, event handlers should be declared as exports on the root module.");
    }
    if (type === "fetch")
      this.#calledAddFetchEventListener = true;
    if (type === "unhandledrejection" && listener) {
      if (this.#unhandledRejectionListeners.size === 0) {
        this.#log.verbose("Adding process unhandledRejection listener...");
        process.prependListener("unhandledRejection", this.#unhandledRejectionListener);
      }
      this.#unhandledRejectionListeners.add(listener);
    }
    if (type === "rejectionhandled" && listener) {
      if (this.#rejectionHandledListeners.size === 0) {
        this.#log.verbose("Adding process rejectionHandled listener...");
        process.prependListener("rejectionHandled", this.#rejectionHandledListener);
      }
      this.#rejectionHandledListeners.add(listener);
    }
    super.addEventListener(type, listener, options);
  };
  removeEventListener = (type, listener, options) => {
    if (this.#modules) {
      throw new TypeError("Global removeEventListener() cannot be used in modules. Instead, event handlers should be declared as exports on the root module.");
    }
    if (type === "unhandledrejection" && listener) {
      const registered = this.#unhandledRejectionListeners.size > 0;
      this.#unhandledRejectionListeners.delete(listener);
      if (registered && this.#unhandledRejectionListeners.size === 0) {
        this.#log.verbose("Removing process unhandledRejection listener...");
        process.removeListener("unhandledRejection", this.#unhandledRejectionListener);
      }
    }
    if (type === "rejectionhandled" && listener) {
      const registered = this.#rejectionHandledListeners.size > 0;
      this.#rejectionHandledListeners.delete(listener);
      if (registered && this.#rejectionHandledListeners.size === 0) {
        this.#log.verbose("Removing process rejectionHandled listener...");
        process.removeListener("rejectionHandled", this.#rejectionHandledListener);
      }
    }
    super.removeEventListener(type, listener, options);
  };
  dispatchEvent = (event) => {
    if (this.#modules) {
      throw new TypeError("Global dispatchEvent() cannot be used in modules. Instead, event handlers should be declared as exports on the root module.");
    }
    return super.dispatchEvent(event);
  };
  [kAddModuleFetchListener](listener) {
    this.#calledAddFetchEventListener = true;
    super.addEventListener("fetch", (e) => {
      const ctx = new ExecutionContext(e);
      const res = listener(e.request, this.#bindings, ctx);
      e.respondWith(res);
    });
  }
  [kAddModuleScheduledListener](listener) {
    super.addEventListener("scheduled", (e) => {
      const controller = new ScheduledController(e.scheduledTime, e.cron);
      const ctx = new ExecutionContext(e);
      const res = listener(controller, this.#bindings, ctx);
      if (res !== void 0)
        e.waitUntil(Promise.resolve(res));
    });
  }
  async [kDispatchFetch](request, proxy = false) {
    const event = new FetchEvent("fetch", {
      request: proxy ? request.clone() : request
    });
    let res;
    try {
      super.dispatchEvent(event);
      res = await event[kResponse];
    } catch (e) {
      if (event[kPassThrough]) {
        this.#log.warn(e.stack);
      } else {
        throw e;
      }
    } finally {
      event[kSent] = true;
    }
    if (res !== void 0) {
      const validRes = res instanceof Response || res instanceof BaseResponse2;
      if (!validRes) {
        const suggestion = this.#modules ? SUGGEST_RES_MODULES : SUGGEST_RES;
        throw new FetchError("ERR_RESPONSE_TYPE", `Fetch handler didn't respond with a Response object.
Make sure you're ${suggestion}.`);
      }
      const waitUntil2 = Promise.all(event[kWaitUntil2]);
      return withWaitUntil(res, waitUntil2);
    }
    if (!proxy) {
      if (event[kPassThrough]) {
        throw new FetchError("ERR_NO_UPSTREAM", "No upstream to pass-through to specified.\nMake sure you've set the `upstream` option.");
      } else if (this.#calledAddFetchEventListener) {
        const suggestion = this.#modules ? SUGGEST_RES_MODULES : SUGGEST_RES;
        throw new FetchError("ERR_NO_RESPONSE", `No fetch handler responded and no upstream to proxy to specified.
Make sure you're ${suggestion}.`);
      } else {
        const suggestion = this.#modules ? SUGGEST_HANDLER_MODULES : SUGGEST_HANDLER;
        throw new FetchError("ERR_NO_HANDLER", `No fetch handler defined and no upstream to proxy to specified.
Make sure you're ${suggestion}.`);
      }
    }
    const waitUntil = Promise.all(event[kWaitUntil2]);
    return withWaitUntil(await fetch2(request[kInner]), waitUntil);
  }
  async [kDispatchScheduled](scheduledTime, cron) {
    const event = new ScheduledEvent("scheduled", {
      scheduledTime: scheduledTime ?? Date.now(),
      cron: cron ?? ""
    });
    super.dispatchEvent(event);
    return await Promise.all(event[kWaitUntil2]);
  }
  #unhandledRejectionListener = (reason, promise) => {
    const event = new PromiseRejectionEvent("unhandledrejection", {
      reason,
      promise
    });
    const notCancelled = super.dispatchEvent(event);
    if (notCancelled) {
      process.removeListener("unhandledRejection", this.#unhandledRejectionListener);
      Promise.reject(reason);
    }
  };
  #rejectionHandledListener = (promise) => {
    const event = new PromiseRejectionEvent("rejectionhandled", { promise });
    super.dispatchEvent(event);
  };
  [kDispose]() {
    if (this.#unhandledRejectionListeners.size > 0) {
      this.#log.verbose("Removing process unhandledRejection listener...");
      process.removeListener("unhandledRejection", this.#unhandledRejectionListener);
    }
    this.#unhandledRejectionListeners.clear();
    if (this.#rejectionHandledListeners.size > 0) {
      this.#log.verbose("Removing process rejectionHandled listener...");
      process.removeListener("rejectionHandled", this.#rejectionHandledListener);
    }
    this.#rejectionHandledListeners.clear();
  }
};

// packages/core/src/standards/streams.ts
import {
  ReadableStreamBYOBReader
} from "stream/web";
ReadableStreamBYOBReader.prototype.readAtLeast = async function(bytes, view) {
  const { byteOffset, byteLength } = view;
  if (isNaN(bytes) || bytes <= 0) {
    throw new TypeError(`Requested invalid minimum number of bytes to read (${bytes}).`);
  }
  if (byteLength <= 0) {
    throw new TypeError('You must call read() on a "byob" reader with a positive-sized TypedArray object.');
  }
  if (bytes > byteLength) {
    throw new TypeError(`Minimum bytes to read (${bytes}) exceeds size of buffer (${byteLength}).`);
  }
  const proto = Object.getPrototypeOf(view);
  const bytesPerElement = proto.BYTES_PER_ELEMENT ?? 1;
  const ctor = proto.constructor;
  let buffer = view.buffer;
  let read = 0;
  let done = false;
  while (read < byteLength && read < bytes) {
    const result = await this.read(new ctor(buffer, byteOffset + read, (byteLength - read) / bytesPerElement));
    if (result.value) {
      buffer = result.value.buffer;
      read += result.value.byteLength;
    }
    if (result.done) {
      done = read === 0;
      break;
    }
  }
  const value = new ctor(buffer, byteOffset, read / bytesPerElement);
  return { value, done };
};

// packages/core/src/standards/timers.ts
import { waitForOpenInputGate as waitForOpenInputGate2 } from "@miniflare/shared";
function inputGatedSetTimeout(callback, ms, ...args) {
  return setTimeout(async (...args2) => {
    await waitForOpenInputGate2();
    callback(...args2);
  }, ms, ...args);
}
function inputGatedSetInterval(callback, ms, ...args) {
  return setInterval(async (...args2) => {
    await waitForOpenInputGate2();
    callback(...args2);
  }, ms, ...args);
}

// packages/core/src/plugins/core.ts
var DEFAULT_MODULE_RULES = [
  { type: "ESModule", include: ["**/*.mjs"] },
  { type: "CommonJS", include: ["**/*.js", "**/*.cjs"] }
];
function proxyStringFormDataFiles(klass) {
  return new Proxy(klass, {
    construct(target, args, newTarget) {
      const value = Reflect.construct(target, args, newTarget);
      return withStringFormDataFiles(value);
    }
  });
}
var CorePlugin = class extends Plugin3 {
  script;
  scriptPath;
  wranglerConfigPath;
  wranglerConfigEnv;
  packagePath;
  modules;
  modulesRules;
  compatibilityDate;
  compatibilityFlags;
  upstream;
  watch;
  debug;
  verbose;
  updateCheck;
  rootPath;
  mounts;
  processedModuleRules = [];
  #globals;
  constructor(ctx, options) {
    super(ctx);
    this.assignOptions(options);
    let CompatRequest = Request;
    let CompatResponse = Response;
    const formDataFiles = ctx.compat.isEnabled("formdata_parser_supports_files");
    if (!formDataFiles) {
      CompatRequest = proxyStringFormDataFiles(CompatRequest);
      CompatResponse = proxyStringFormDataFiles(CompatResponse);
    }
    this.#globals = {
      console,
      setTimeout: inputGatedSetTimeout,
      setInterval: inputGatedSetInterval,
      clearTimeout,
      clearInterval,
      queueMicrotask,
      atob,
      btoa,
      crypto,
      CryptoKey: crypto.CryptoKey,
      TextDecoder,
      TextEncoder,
      fetch: createCompatFetch(ctx.compat),
      Headers: Headers2,
      Request: CompatRequest,
      Response: CompatResponse,
      FormData: FormData2,
      Blob,
      File: File2,
      URL: URL2,
      URLSearchParams,
      ByteLengthQueuingStrategy,
      CountQueuingStrategy,
      ReadableByteStreamController,
      ReadableStream: ReadableStream2,
      ReadableStreamBYOBReader: ReadableStreamBYOBReader2,
      ReadableStreamBYOBRequest,
      ReadableStreamDefaultController,
      ReadableStreamDefaultReader,
      TransformStream,
      TransformStreamDefaultController,
      WritableStream,
      WritableStreamDefaultController,
      WritableStreamDefaultWriter,
      Event,
      EventTarget,
      AbortController,
      AbortSignal,
      FetchEvent,
      ScheduledEvent,
      DOMException,
      WorkerGlobalScope,
      ArrayBuffer,
      Atomics,
      BigInt64Array,
      BigUint64Array,
      DataView,
      Date,
      Float32Array,
      Float64Array,
      Int8Array,
      Int16Array,
      Int32Array,
      Map,
      Set,
      SharedArrayBuffer,
      Uint8Array,
      Uint8ClampedArray,
      Uint16Array,
      Uint32Array,
      WeakMap,
      WeakSet,
      WebAssembly,
      MINIFLARE: true
    };
    if (!this.modules)
      return;
    const finalisedTypes = new Set();
    for (const rule of [
      ...this.modulesRules ?? [],
      ...DEFAULT_MODULE_RULES
    ]) {
      if (finalisedTypes.has(rule.type))
        continue;
      this.processedModuleRules.push({
        type: rule.type,
        include: globsToMatcher(rule.include)
      });
      if (!rule.fallthrough)
        finalisedTypes.add(rule.type);
    }
  }
  async setup() {
    const globals = this.#globals;
    if (this.script !== void 0) {
      return {
        globals,
        script: { filePath: STRING_SCRIPT_PATH, code: this.script }
      };
    }
    const watch = [];
    let scriptPath = this.scriptPath;
    if (scriptPath === void 0) {
      const packagePath = this.packagePath === true ? path4.join(this.ctx.rootPath, "package.json") : this.packagePath;
      if (packagePath) {
        try {
          const pkg = JSON.parse(await fs2.readFile(packagePath, "utf8"));
          scriptPath = this.modules ? pkg.module : pkg.main;
          scriptPath &&= path4.resolve(path4.dirname(packagePath), scriptPath);
        } catch (e) {
          if (!(e.code === "ENOENT" && this.packagePath === true))
            throw e;
        }
        watch.push(packagePath);
      }
    }
    if (scriptPath !== void 0) {
      scriptPath = path4.resolve(scriptPath);
      const code = await fs2.readFile(scriptPath, "utf8");
      watch.push(scriptPath);
      return { globals, script: { filePath: scriptPath, code }, watch };
    }
    return { globals, watch };
  }
};
__decorateClass([
  Option3({ type: OptionType3.NONE, logValue: () => STRING_SCRIPT_PATH })
], CorePlugin.prototype, "script", 2);
__decorateClass([
  Option3({
    type: OptionType3.STRING_POSITIONAL,
    name: "script",
    fromWrangler: ({ build }, configDir) => build?.upload?.main ? path4.resolve(configDir, build?.upload?.dir ?? "dist", build.upload.main) : void 0
  })
], CorePlugin.prototype, "scriptPath", 2);
__decorateClass([
  Option3({
    type: OptionType3.STRING,
    name: "wrangler-config",
    alias: "c",
    description: "Path to wrangler.toml",
    logValue(value) {
      if (value === true)
        return "wrangler.toml";
      if (value === false)
        return void 0;
      return path4.relative("", value);
    }
  })
], CorePlugin.prototype, "wranglerConfigPath", 2);
__decorateClass([
  Option3({
    type: OptionType3.STRING,
    name: "wrangler-env",
    description: "Environment in wrangler.toml to use",
    logName: "Wrangler Environment"
  })
], CorePlugin.prototype, "wranglerConfigEnv", 2);
__decorateClass([
  Option3({
    type: OptionType3.STRING,
    name: "package",
    description: "Path to package.json",
    logValue(value) {
      if (value === true)
        return "package.json";
      if (value === false)
        return void 0;
      return path4.relative("", value);
    }
  })
], CorePlugin.prototype, "packagePath", 2);
__decorateClass([
  Option3({
    type: OptionType3.BOOLEAN,
    alias: "m",
    description: "Enable modules",
    fromWrangler: ({ build }) => build?.upload?.format && build.upload.format === "modules"
  })
], CorePlugin.prototype, "modules", 2);
__decorateClass([
  Option3({
    type: OptionType3.OBJECT,
    typeFormat: "TYPE=GLOB",
    description: "Modules import rule",
    logValue: (value) => value.map((rule) => `{${rule.type}: ${rule.include.join(", ")}}`).join(", "),
    fromEntries: (entries) => entries.map(([type, include]) => ({
      type,
      include: [include],
      fallthrough: true
    })),
    fromWrangler: ({ build }) => build?.upload?.rules?.map(({ type, globs, fallthrough }) => ({
      type,
      include: globs,
      fallthrough
    }))
  })
], CorePlugin.prototype, "modulesRules", 2);
__decorateClass([
  Option3({
    type: OptionType3.STRING,
    name: "compat-date",
    description: "Opt into backwards-incompatible changes from",
    fromWrangler: ({ compatibility_date }) => compatibility_date
  })
], CorePlugin.prototype, "compatibilityDate", 2);
__decorateClass([
  Option3({
    type: OptionType3.ARRAY,
    name: "compat-flag",
    description: "Control specific backwards-incompatible changes",
    fromWrangler: ({ compatibility_flags }) => compatibility_flags
  })
], CorePlugin.prototype, "compatibilityFlags", 2);
__decorateClass([
  Option3({
    type: OptionType3.STRING,
    alias: "u",
    description: "URL of upstream origin",
    fromWrangler: ({ miniflare }) => miniflare?.upstream
  })
], CorePlugin.prototype, "upstream", 2);
__decorateClass([
  Option3({
    type: OptionType3.BOOLEAN,
    alias: "w",
    description: "Watch files for changes",
    fromWrangler: ({ miniflare }) => miniflare?.watch
  })
], CorePlugin.prototype, "watch", 2);
__decorateClass([
  Option3({
    type: OptionType3.BOOLEAN,
    alias: "d",
    description: "Enable debug logging"
  })
], CorePlugin.prototype, "debug", 2);
__decorateClass([
  Option3({
    type: OptionType3.BOOLEAN,
    alias: "V",
    description: "Enable verbose logging"
  })
], CorePlugin.prototype, "verbose", 2);
__decorateClass([
  Option3({
    type: OptionType3.BOOLEAN,
    description: "Enable update checker (enabled by default)",
    negatable: true,
    fromWrangler: ({ miniflare }) => miniflare?.update_check
  })
], CorePlugin.prototype, "updateCheck", 2);
__decorateClass([
  Option3({
    type: OptionType3.STRING,
    name: "root",
    description: "Path to resolve default config files relative to"
  })
], CorePlugin.prototype, "rootPath", 2);
__decorateClass([
  Option3({
    type: OptionType3.OBJECT,
    typeFormat: "NAME=PATH",
    description: "Mount additional named workers",
    fromWrangler: ({ miniflare }) => miniflare?.mounts
  })
], CorePlugin.prototype, "mounts", 2);

// packages/core/src/storage.ts
import path5 from "path";
var PluginStorageFactory = class {
  constructor(inner, pluginName, defaultPersistRoot = ".mf") {
    this.inner = inner;
    this.defaultPersistRoot = defaultPersistRoot;
    this.pluginName = pluginName.substring(0, pluginName.length - 6).toLowerCase();
  }
  pluginName;
  storage(namespace, persist) {
    if (persist === void 0 || persist === false) {
      return this.inner.storage(`${this.pluginName}:` + namespace);
    } else if (persist === true) {
      return this.inner.storage(namespace, path5.join(this.defaultPersistRoot, this.pluginName));
    } else {
      return this.inner.storage(namespace, persist);
    }
  }
  dispose() {
    return this.inner.dispose?.();
  }
};

// packages/core/src/index.ts
function _deepEqual(a, b) {
  if (!dequal(a, b))
    return false;
  if (typeof a === "object") {
    const aSymbols = Object.getOwnPropertySymbols(a);
    for (const aSymbol of aSymbols) {
      if (!(aSymbol in b) || !dequal(a[aSymbol], b[aSymbol]))
        return false;
    }
    return aSymbols.length === Object.getOwnPropertySymbols(b).length;
  }
  return true;
}
var MiniflareCoreError = class extends MiniflareError3 {
};
function getPluginEntries(plugins) {
  const entries = Object.entries(plugins);
  let coreIndex = -1;
  let bindingsIndex = -1;
  for (let i = 0; i < entries.length; i++) {
    const [, plugin] = entries[i];
    if (plugin === CorePlugin)
      coreIndex = i;
    else if (plugin === BindingsPlugin)
      bindingsIndex = i;
  }
  if (coreIndex > 0) {
    entries.unshift(...entries.splice(coreIndex, 1));
  }
  if (bindingsIndex !== -1 && bindingsIndex !== entries.length - 1) {
    entries.push(...entries.splice(bindingsIndex, 1));
  }
  return entries;
}
function splitPluginOptions(plugins, options) {
  const result = {};
  for (const [name, plugin] of plugins) {
    const pluginResult = {};
    for (const key of plugin.prototype.opts?.keys() ?? []) {
      if (key in options) {
        pluginResult[key] = options[key];
      }
    }
    result[name] = pluginResult;
  }
  return result;
}
function splitWranglerConfig(plugins, overrides, config, configDir) {
  const result = {};
  for (const [name, plugin] of plugins) {
    const pluginResult = {};
    const pluginOverrides = overrides[name];
    for (const [key, meta] of plugin.prototype.opts?.entries() ?? []) {
      pluginResult[key] = pluginOverrides[key] ?? meta.fromWrangler?.(config, configDir);
    }
    result[name] = pluginResult;
  }
  return result;
}
var pathResolve = (p) => path6.resolve(p);
function throwNoScriptError(modules) {
  const execName = process.env.MINIFLARE_EXEC_NAME ?? "miniflare";
  const script = modules ? "worker.mjs" : "worker.js";
  const format = modules ? "modules" : "service-worker";
  const pkgScriptField = modules ? "module" : "main";
  const lines = [
    "No script defined, either:",
    "- Pass it as a positional argument, if you're using the CLI",
    dim(`    $ ${execName} dist/${script}`),
    "- Set the script or scriptPath option, if you're using the API",
    dim(`    new Miniflare({ scriptPath: "dist/${script}" })`),
    `- Set ${pkgScriptField} in package.json`,
    dim(`    { "${pkgScriptField}": "dist/${script}" }`)
  ];
  if (modules) {
    lines.push("- Set build.upload.main in wrangler.toml", dim("    [build.upload]"), dim(`    format = "${format}"`), dim(`    dir = "dist"`), dim(`    main = "${script}"`));
  }
  lines.push("");
  throw new MiniflareCoreError("ERR_NO_SCRIPT", lines.join("\n"));
}
var ReloadEvent = class extends Event {
  constructor(plugins, initial) {
    super("reload");
    this.plugins = plugins;
    this.initial = initial;
  }
};
var MiniflareCore = class extends TypedEventTarget {
  #originalPlugins;
  #plugins;
  #previousSetOptions;
  #overrides;
  #previousOptions;
  #ctx;
  #pluginStorages;
  #compat;
  #previousRootPath;
  #instances;
  #mounts;
  #wranglerConfigPath;
  #watching;
  #beforeSetupWatch;
  #setupWatch;
  #setupResults;
  #scriptWatchPaths = new Set();
  #reloaded = false;
  #globalScope;
  #bindings;
  #moduleExports;
  #watcher;
  #watcherCallbackMutex;
  #previousWatchPaths;
  constructor(plugins, ctx, options = {}) {
    super();
    this.#originalPlugins = plugins;
    this.#plugins = getPluginEntries(plugins);
    this.#previousSetOptions = options;
    this.#overrides = splitPluginOptions(this.#plugins, options);
    this.#ctx = ctx;
    this.#pluginStorages = new Map();
    this.#initPromise = this.#init().then(() => this.#reload());
  }
  #updateWatch(data, name, result) {
    if (this.#watching && result?.watch) {
      const resolved = result.watch.map(pathResolve);
      data.set(name, new Set(resolved));
    } else {
      data.delete(name);
    }
  }
  async #runBeforeSetup(name) {
    const instance = this.#instances[name];
    if (!instance.beforeSetup)
      return false;
    this.#ctx.log.verbose(`- beforeSetup(${name})`);
    const result = await instance.beforeSetup();
    this.#updateWatch(this.#beforeSetupWatch, name, result);
    return true;
  }
  async #runSetup(name) {
    const instance = this.#instances[name];
    if (!instance.setup)
      return false;
    this.#ctx.log.verbose(`- setup(${name})`);
    const result = await instance.setup(this.getPluginStorage(name));
    this.#updateWatch(this.#setupWatch, name, result);
    this.#setupResults.set(name, result ?? {});
    return true;
  }
  #initPromise;
  async #init() {
    this.#ctx.log.debug("Initialising worker...");
    const previous = this.#previousOptions;
    let options = this.#overrides;
    const rootPath = options.CorePlugin.rootPath ?? process.cwd();
    const originalConfigPath = options.CorePlugin.wranglerConfigPath;
    const configEnv = options.CorePlugin.wranglerConfigEnv;
    let configPath = originalConfigPath === true ? path6.join(rootPath, "wrangler.toml") : originalConfigPath;
    if (configPath) {
      configPath = path6.resolve(configPath);
      this.#wranglerConfigPath = configPath;
      try {
        const configData = await fs3.readFile(configPath, "utf8");
        const toml = await import("@iarna/toml");
        const config = toml.parse(configData);
        if (configEnv && config.env && configEnv in config.env) {
          Object.assign(config, config.env[configEnv]);
        }
        const configDir = path6.dirname(configPath);
        populateBuildConfig(config, configDir, configEnv);
        options = splitWranglerConfig(this.#plugins, this.#overrides, config, configDir);
      } catch (e) {
        if (!(e.code === "ENOENT" && originalConfigPath === true)) {
          throw e;
        }
      }
    }
    this.#watching ??= options.CorePlugin.watch ?? false;
    const { compatibilityDate, compatibilityFlags } = options.CorePlugin;
    let ctxUpdate = this.#previousRootPath && this.#previousRootPath !== rootPath;
    this.#previousRootPath = rootPath;
    if (this.#compat) {
      if (this.#compat.update(compatibilityDate, compatibilityFlags)) {
        ctxUpdate = true;
      }
    } else {
      this.#compat = new Compatibility2(compatibilityDate, compatibilityFlags);
    }
    const ctx = {
      log: this.#ctx.log,
      compat: this.#compat,
      rootPath
    };
    logOptions(this.#plugins, this.#ctx.log, options);
    const enabled = this.#compat.enabled;
    this.#ctx.log.debug(`Enabled Compatibility Flags:${enabled.length === 0 ? " <none>" : ""}`);
    for (const flag of enabled)
      this.#ctx.log.debug(`- ${flag}`);
    this.#instances ??= {};
    this.#beforeSetupWatch ??= new Map();
    let ranBeforeSetup = false;
    for (const [name, plugin] of this.#plugins) {
      if (previous !== void 0 && !ctxUpdate && _deepEqual(previous[name], options[name])) {
        continue;
      }
      const existingInstance = this.#instances[name];
      if (existingInstance?.dispose) {
        this.#ctx.log.verbose(`- dispose(${name})`);
        await existingInstance.dispose();
      }
      const instance = new plugin(ctx, options[name]);
      this.#instances[name] = instance;
      if (await this.#runBeforeSetup(name))
        ranBeforeSetup = true;
    }
    this.#setupWatch ??= new Map();
    this.#setupResults ??= new Map();
    for (const [name] of this.#plugins) {
      if (previous !== void 0 && !ctxUpdate && _deepEqual(previous[name], options[name]) && !(ranBeforeSetup && this.#setupResults.get(name)?.script)) {
        continue;
      }
      await this.#runSetup(name);
    }
    this.#previousOptions = options;
    if (this.#ctx.scriptRequired && !this.#setupResults.get("CorePlugin")?.script) {
      throwNoScriptError(options.CorePlugin.modules);
    }
    this.#mounts ??= new Map();
    const mounts = options.CorePlugin.mounts;
    if (mounts) {
      for (const [name, rawOptions] of Object.entries(mounts)) {
        if (name === "") {
          throw new MiniflareCoreError("ERR_MOUNT_NO_NAME", "Mount name cannot be empty");
        }
        const options2 = typeof rawOptions === "string" ? {
          packagePath: true,
          envPath: true,
          wranglerConfigPath: true,
          watch: this.#watching,
          rootPath: rawOptions
        } : rawOptions;
        if ("mounts" in options2) {
          throw new MiniflareCoreError("ERR_MOUNT_NESTED", "Nested mounts are unsupported");
        }
        let mount = this.#mounts.get(name);
        if (mount) {
          this.#ctx.log.verbose(`Updating mount "${name}"...`);
          await mount.setOptions(options2);
        } else {
          this.#ctx.log.debug(`Mounting "${name}"...`);
          let log = this.#ctx.log;
          if (Object.getPrototypeOf(this.#ctx.log) === Log3.prototype) {
            log = new Log3(this.#ctx.log.level, name);
          }
          const ctx2 = {
            ...this.#ctx,
            log,
            scriptRunForModuleExports: false
          };
          mount = new MiniflareCore(this.#originalPlugins, ctx2, options2);
          mount.addEventListener("reload", (event) => {
            if (!event.initial)
              this.#reload();
          });
          try {
            await mount.getPlugins();
          } catch (e) {
            throw new MiniflareCoreError("ERR_MOUNT", `Error mounting "${name}"`, e);
          }
          this.#mounts.set(name, mount);
        }
      }
      for (const [name, mount] of [...this.#mounts]) {
        if (!(name in mounts)) {
          this.#ctx.log.debug(`Unmounting "${name}"...`);
          await mount.dispose();
          this.#mounts.delete(name);
        }
      }
    }
  }
  async #reload() {
    this.#ctx.log.debug("Reloading worker...");
    const globals = {};
    const bindings = {};
    const newWatchPaths = new Set();
    if (this.#wranglerConfigPath)
      newWatchPaths.add(this.#wranglerConfigPath);
    let script = void 0;
    let requiresModuleExports = false;
    const additionalModules = {};
    for (const [name] of this.#plugins) {
      const instance = this.#instances[name];
      if (instance.beforeReload) {
        this.#ctx.log.verbose(`- beforeReload(${name})`);
        await instance.beforeReload();
      }
      const result = this.#setupResults.get(name);
      Object.assign(globals, result?.globals);
      Object.assign(bindings, result?.bindings);
      if (result?.script) {
        if (script) {
          throw new TypeError("Multiple plugins returned a script");
        }
        script = result.script;
      }
      if (result?.requiresModuleExports)
        requiresModuleExports = true;
      if (result?.additionalModules) {
        Object.assign(additionalModules, result.additionalModules);
      }
      const beforeSetupWatch = this.#beforeSetupWatch.get(name);
      if (beforeSetupWatch)
        addAll(newWatchPaths, beforeSetupWatch);
      const setupWatch = this.#setupWatch.get(name);
      if (setupWatch)
        addAll(newWatchPaths, setupWatch);
    }
    const { modules, processedModuleRules } = this.#instances.CorePlugin;
    this.#globalScope?.[kDispose]();
    const globalScope = new ServiceWorkerGlobalScope(this.#ctx.log, globals, bindings, modules);
    this.#globalScope = globalScope;
    this.#bindings = bindings;
    const rules = modules ? processedModuleRules : void 0;
    let res = void 0;
    if (script && (!this.#ctx.scriptRunForModuleExports || modules && requiresModuleExports)) {
      if (!this.#ctx.scriptRunner) {
        throw new TypeError("Running scripts requires a script runner");
      }
      this.#ctx.log.verbose("Running script...");
      res = await this.#ctx.scriptRunner.run(globalScope, script, rules, additionalModules);
      this.#scriptWatchPaths.clear();
      this.#scriptWatchPaths.add(script.filePath);
      if (res.watch) {
        addAll(newWatchPaths, res.watch);
        addAll(this.#scriptWatchPaths, res.watch);
      }
      this.#moduleExports = res.exports;
      if (res.exports) {
        const defaults = res.exports.default;
        const fetchListener = defaults?.fetch?.bind(defaults);
        if (fetchListener) {
          globalScope[kAddModuleFetchListener](fetchListener);
        }
        const scheduledListener = defaults?.scheduled?.bind(defaults);
        if (scheduledListener) {
          globalScope[kAddModuleScheduledListener](scheduledListener);
        }
      }
    }
    const moduleExports = res?.exports ?? {};
    const mountedModuleExports = {};
    for (const [name, mount] of this.#mounts) {
      mountedModuleExports[name] = await mount.getModuleExports();
    }
    for (const [name] of this.#plugins) {
      const instance = this.#instances[name];
      if (instance.reload) {
        this.#ctx.log.verbose(`- reload(${name})`);
        await instance.reload(bindings, moduleExports, mountedModuleExports);
      }
    }
    this.dispatchEvent(new ReloadEvent(this.#instances, !this.#reloaded));
    this.#reloaded = true;
    this.#ctx.log.info(`Worker reloaded!${res?.bundleSize !== void 0 ? ` (${formatSize(res.bundleSize)})` : ""}`);
    if (res?.bundleSize !== void 0 && res.bundleSize > 1048576) {
      this.#ctx.log.warn("Worker's uncompressed size exceeds the 1MiB limit! Note that your worker will be compressed during upload so you may still be able to deploy it.");
    }
    if (this.#watching) {
      let watcher = this.#watcher;
      if (!watcher) {
        const { Watcher } = await import("@miniflare/watcher");
        this.#watcherCallbackMutex = new Mutex();
        watcher = new Watcher(this.#watcherCallback.bind(this));
        this.#watcher = watcher;
      }
      const unwatchedPaths = new Set();
      const watchedPaths = new Set();
      for (const watchedPath of this.#previousWatchPaths ?? []) {
        if (!newWatchPaths.has(watchedPath)) {
          unwatchedPaths.add(watchedPath);
        }
      }
      for (const newWatchedPath of newWatchPaths) {
        if (!this.#previousWatchPaths?.has(newWatchedPath)) {
          watchedPaths.add(newWatchedPath);
        }
      }
      if (unwatchedPaths.size > 0) {
        this.#ctx.log.debug(`Unwatching ${pathsToString(unwatchedPaths)}...`);
        watcher.unwatch(unwatchedPaths);
      }
      if (watchedPaths.size > 0) {
        this.#ctx.log.debug(`Watching ${pathsToString(newWatchPaths)}...`);
        await watcher.watch(watchedPaths);
      }
      this.#previousWatchPaths = newWatchPaths;
    }
  }
  #ignoreScriptUpdates = false;
  #ignoreScriptUpdatesTimeout;
  #watcherCallback(eventPath) {
    this.#ctx.log.debug(`${path6.relative("", eventPath)} changed...`);
    if (this.#ignoreScriptUpdates && this.#scriptWatchPaths.has(eventPath)) {
      this.#ctx.log.verbose("Ignoring script change after build...");
      return;
    }
    const promise = this.#watcherCallbackMutex.runWith(async () => {
      if (eventPath === this.#wranglerConfigPath) {
        await this.#init();
      }
      let ranBeforeSetup = false;
      for (const [name] of this.#plugins) {
        if (this.#beforeSetupWatch.get(name)?.has(eventPath)) {
          await this.#runBeforeSetup(name);
          ranBeforeSetup = true;
          this.#ignoreScriptUpdates = true;
          clearTimeout(this.#ignoreScriptUpdatesTimeout);
          this.#ignoreScriptUpdatesTimeout = setTimeout(() => this.#ignoreScriptUpdates = false, 1e3);
        }
        if (this.#setupWatch.get(name)?.has(eventPath)) {
          await this.#runSetup(name);
        }
      }
      if (ranBeforeSetup) {
        for (const [name] of this.#plugins) {
          if (this.#setupResults.get(name)?.script) {
            await this.#runSetup(name);
          }
        }
      }
      if (!this.#watcherCallbackMutex.hasWaiting) {
        await this.#reload();
      }
    });
    promise.catch((e) => this.#ctx.log.error(e));
  }
  get log() {
    return this.#ctx.log;
  }
  async reload() {
    await this.#initPromise;
    await this.#init();
    await this.#reload();
  }
  async setOptions(options) {
    await this.#initPromise;
    options = { ...this.#previousSetOptions, ...options };
    this.#previousSetOptions = options;
    this.#overrides = splitPluginOptions(this.#plugins, options);
    await this.#init();
    await this.#reload();
  }
  getPluginStorage(name) {
    let storage = this.#pluginStorages.get(name);
    if (storage)
      return storage;
    this.#pluginStorages.set(name, storage = new PluginStorageFactory(this.#ctx.storageFactory, name));
    return storage;
  }
  async getPlugins() {
    await this.#initPromise;
    return this.#instances;
  }
  async getGlobalScope() {
    await this.#initPromise;
    return this.#globalScope;
  }
  async getBindings() {
    await this.#initPromise;
    return this.#bindings;
  }
  async getModuleExports() {
    await this.#initPromise;
    return this.#moduleExports;
  }
  async getMount(name) {
    await this.#initPromise;
    return this.#mounts.get(name);
  }
  async dispatchFetch(input, init) {
    await this.#initPromise;
    let request = input instanceof Request && !init ? input : new Request(input, init);
    if (this.#mounts?.size) {
      const url = new URL3(request.url);
      for (const [name, mount] of this.#mounts) {
        const prefix = `/${name}`;
        if (url.pathname === prefix || url.pathname.startsWith(`${prefix}/`)) {
          url.pathname = url.pathname.slice(prefix.length);
          return mount.dispatchFetch(new Request(url, request));
        }
      }
    }
    const corePlugin = this.#instances.CorePlugin;
    const globalScope = this.#globalScope;
    if (!this.#compat.isEnabled("formdata_parser_supports_files")) {
      request = withStringFormDataFiles(request);
    }
    return globalScope[kDispatchFetch](withImmutableHeaders(request), !!corePlugin.upstream);
  }
  async dispatchScheduled(scheduledTime, cron) {
    await this.#initPromise;
    const globalScope = this.#globalScope;
    return globalScope[kDispatchScheduled](scheduledTime, cron);
  }
  async dispose() {
    for (const [name] of this.#plugins) {
      const instance = this.#instances?.[name];
      if (instance?.dispose) {
        this.#ctx.log.verbose(`- dispose(${name})`);
        await instance.dispose();
      }
    }
    this.#watcher?.dispose();
    if (this.#mounts) {
      for (const [name, mount] of this.#mounts) {
        this.#ctx.log.debug(`Unmounting "${name}"...`);
        await mount.dispose();
      }
      this.#mounts.clear();
    }
  }
};
export {
  BindingsPlugin,
  Body,
  BuildError,
  BuildPlugin,
  CorePlugin,
  DOMException,
  DOM_EXCEPTION_NAMES,
  ExecutionContext,
  FetchError,
  FetchEvent,
  MiniflareCore,
  MiniflareCoreError,
  PluginStorageFactory,
  PromiseRejectionEvent,
  ReloadEvent,
  Request,
  Response,
  ScheduledController,
  ScheduledEvent,
  ServiceWorkerGlobalScope,
  TextDecoder,
  WorkerGlobalScope,
  _deepEqual,
  createCompatFetch,
  crypto,
  fetch,
  inputGatedSetInterval,
  inputGatedSetTimeout,
  kAddModuleFetchListener,
  kAddModuleScheduledListener,
  kDispatchFetch,
  kDispatchScheduled,
  kDispose,
  logResponse,
  populateBuildConfig,
  withImmutableHeaders,
  withInputGating,
  withStringFormDataFiles,
  withWaitUntil
};
//# sourceMappingURL=index.js.map
