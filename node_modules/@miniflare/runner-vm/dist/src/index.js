// packages/runner-vm/src/index.ts
import vm2 from "vm";

// packages/runner-vm/src/error.ts
import { MiniflareError } from "@miniflare/shared";
var VMScriptRunnerError = class extends MiniflareError {
};

// packages/runner-vm/src/linker.ts
import { readFileSync } from "fs";
import fs from "fs/promises";
import path from "path";
import vm from "vm";
import {
  STRING_SCRIPT_PATH,
  viewToBuffer
} from "@miniflare/shared";
var ModuleLinker = class {
  constructor(moduleRules, additionalModules) {
    this.moduleRules = moduleRules;
    this.additionalModules = additionalModules;
    this.linker = this.linker.bind(this);
  }
  #referencedPathSizes = new Map();
  #moduleCache = new Map();
  #cjsModuleCache = new Map();
  get referencedPaths() {
    return this.#referencedPathSizes.keys();
  }
  get referencedPathsTotalSize() {
    const sizes = Array.from(this.#referencedPathSizes.values());
    return sizes.reduce((total, size) => total + size, 0);
  }
  async linker(spec, referencing) {
    const relative = path.relative("", referencing.identifier);
    const errorBase = `Unable to resolve "${relative}" dependency "${spec}"`;
    if (referencing.identifier === STRING_SCRIPT_PATH) {
      throw new VMScriptRunnerError("ERR_MODULE_STRING_SCRIPT", `${errorBase}: imports unsupported with string script`);
    }
    const additionalModule = this.additionalModules[spec];
    const identifier = additionalModule ? spec : path.resolve(path.dirname(referencing.identifier), spec);
    const cached = this.#moduleCache.get(identifier);
    if (cached)
      return cached;
    const moduleOptions = { identifier, context: referencing.context };
    let module;
    if (additionalModule) {
      module = new vm.SyntheticModule(Object.keys(additionalModule), function() {
        for (const [key, value] of Object.entries(additionalModule)) {
          this.setExport(key, value);
        }
      }, moduleOptions);
      this.#moduleCache.set(identifier, module);
      return module;
    }
    const relativeIdentifier = path.relative("", identifier);
    const rule = this.moduleRules.find((rule2) => rule2.include.test(relativeIdentifier));
    if (rule === void 0) {
      throw new VMScriptRunnerError("ERR_MODULE_RULE", `${errorBase}: no matching module rules`);
    }
    const data = await fs.readFile(identifier);
    this.#referencedPathSizes.set(identifier, data.byteLength);
    switch (rule.type) {
      case "ESModule":
        module = new vm.SourceTextModule(data.toString("utf8"), moduleOptions);
        break;
      case "CommonJS":
        const exports = this.loadCommonJSModule(errorBase, identifier, spec, referencing.context);
        module = new vm.SyntheticModule(["default"], function() {
          this.setExport("default", exports);
        }, moduleOptions);
        break;
      case "Text":
        module = new vm.SyntheticModule(["default"], function() {
          this.setExport("default", data.toString("utf8"));
        }, moduleOptions);
        break;
      case "Data":
        module = new vm.SyntheticModule(["default"], function() {
          this.setExport("default", viewToBuffer(data));
        }, moduleOptions);
        break;
      case "CompiledWasm":
        module = new vm.SyntheticModule(["default"], function() {
          this.setExport("default", new WebAssembly.Module(data));
        }, moduleOptions);
        break;
      default:
        throw new VMScriptRunnerError("ERR_MODULE_UNSUPPORTED", `${errorBase}: ${rule.type} modules are unsupported`);
    }
    this.#moduleCache.set(identifier, module);
    return module;
  }
  loadCommonJSModule(errorBase, identifier, spec, context) {
    const cached = this.#cjsModuleCache.get(identifier);
    if (cached)
      return cached.exports;
    const additionalModule = this.additionalModules[spec];
    const module = { exports: {} };
    if (additionalModule) {
      module.exports.default = additionalModule.default;
      this.#cjsModuleCache.set(identifier, module);
      return module.exports;
    }
    const relativeIdentifier = path.relative("", identifier);
    const rule = this.moduleRules.find((rule2) => rule2.include.test(relativeIdentifier));
    if (rule === void 0) {
      throw new VMScriptRunnerError("ERR_MODULE_RULE", `${errorBase}: no matching module rules`);
    }
    this.#cjsModuleCache.set(identifier, module);
    const data = readFileSync(identifier);
    this.#referencedPathSizes.set(identifier, data.byteLength);
    switch (rule.type) {
      case "ESModule":
        throw new VMScriptRunnerError("ERR_CJS_MODULE_UNSUPPORTED", `${errorBase}: CommonJS modules cannot require ES modules`);
      case "CommonJS":
        const code = data.toString("utf8");
        const wrapped = `(function(exports, require, module) {
${code}
});`;
        const script = new vm.Script(wrapped, {
          filename: identifier,
          lineOffset: -1
        });
        const moduleWrapper = script.runInContext(context);
        const require2 = this.createRequire(identifier, context);
        moduleWrapper(module.exports, require2, module);
        break;
      case "Text":
        module.exports.default = data.toString("utf8");
        break;
      case "Data":
        module.exports.default = viewToBuffer(data);
        break;
      case "CompiledWasm":
        module.exports.default = new WebAssembly.Module(data);
        break;
      default:
        throw new VMScriptRunnerError("ERR_MODULE_UNSUPPORTED", `${errorBase}: ${rule.type} modules are unsupported`);
    }
    return module.exports;
  }
  createRequire(referencingIdentifier, context) {
    const relative = path.relative("", referencingIdentifier);
    const referencingDirname = path.dirname(referencingIdentifier);
    return (spec) => {
      const errorBase = `Unable to resolve "${relative}" dependency "${spec}"`;
      const identifier = path.resolve(referencingDirname, spec);
      return this.loadCommonJSModule(errorBase, identifier, spec, context);
    };
  }
};

// packages/runner-vm/src/proxied.ts
import { types } from "util";
function isObject(value) {
  return value !== null && typeof value === "object";
}
function isFunction(value) {
  return typeof value === "function";
}
function isError(errorCtor) {
  const name = errorCtor.prototype.name;
  return function(value) {
    if (!types.isNativeError(value))
      return false;
    let prototype = value;
    while ((prototype = Object.getPrototypeOf(prototype)) !== null) {
      if (prototype.name === name)
        return true;
    }
    return false;
  };
}
function proxyHasInstance(target, hasInstance, handler) {
  return new Proxy(target, {
    get(target2, property, receiver) {
      if (property === Symbol.hasInstance)
        return hasInstance;
      return Reflect.get(target2, property, receiver);
    },
    ...handler
  });
}
var proxiedGlobals = {
  Object: proxyHasInstance(Object, isObject),
  Array: proxyHasInstance(Array, Array.isArray),
  Promise: proxyHasInstance(Promise, types.isPromise),
  RegExp: proxyHasInstance(RegExp, types.isRegExp),
  Error: proxyHasInstance(Error, isError(Error)),
  EvalError: proxyHasInstance(EvalError, isError(EvalError)),
  RangeError: proxyHasInstance(RangeError, isError(RangeError)),
  ReferenceError: proxyHasInstance(ReferenceError, isError(ReferenceError)),
  SyntaxError: proxyHasInstance(SyntaxError, isError(SyntaxError)),
  TypeError: proxyHasInstance(TypeError, isError(TypeError)),
  URIError: proxyHasInstance(URIError, isError(URIError)),
  Function: proxyHasInstance(Function, isFunction, {
    construct() {
      throw new EvalError("Code generation from strings disallowed for this context");
    }
  })
};

// packages/runner-vm/src/index.ts
var VMScriptRunner = class {
  constructor(context) {
    this.context = context;
  }
  runAsScript(context, blueprint) {
    const script = new vm2.Script(blueprint.code, {
      filename: blueprint.filePath
    });
    script.runInContext(context);
  }
  async runAsModule(context, blueprint, linker) {
    const module = new vm2.SourceTextModule(blueprint.code, {
      identifier: blueprint.filePath,
      context
    });
    await module.link(linker);
    await module.evaluate();
    return module.namespace;
  }
  async run(globalScope, blueprint, modulesRules, additionalModules) {
    if (modulesRules && !("SourceTextModule" in vm2)) {
      throw new VMScriptRunnerError("ERR_MODULE_DISABLED", "Modules support requires the --experimental-vm-modules flag");
    }
    const linker = modulesRules && new ModuleLinker(modulesRules, additionalModules ?? {});
    Object.assign(globalScope, proxiedGlobals);
    let context = this.context;
    if (context) {
      Object.assign(context, globalScope);
    } else {
      context = vm2.createContext(globalScope, {
        codeGeneration: { strings: false, wasm: false }
      });
    }
    let exports = {};
    let bundleSize = 0;
    bundleSize += Buffer.byteLength(blueprint.code);
    if (linker) {
      exports = await this.runAsModule(context, blueprint, linker.linker);
    } else {
      this.runAsScript(context, blueprint);
    }
    if (linker)
      bundleSize += linker.referencedPathsTotalSize;
    const watch = linker && [...linker.referencedPaths];
    return { exports, bundleSize, watch };
  }
};
export {
  VMScriptRunner,
  VMScriptRunnerError,
  proxiedGlobals
};
//# sourceMappingURL=index.js.map
