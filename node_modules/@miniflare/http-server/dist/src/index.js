var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __decorateClass = (decorators, target, key, kind) => {
  var result = kind > 1 ? void 0 : kind ? __getOwnPropDesc(target, key) : target;
  for (var i = decorators.length - 1, decorator; i >= 0; i--)
    if (decorator = decorators[i])
      result = (kind ? decorator(target, key, result) : decorator(result)) || result;
  if (kind && result)
    __defProp(target, key, result);
  return result;
};

// packages/http-server/src/index.ts
import assert from "assert";
import http from "http";
import https from "https";
import { PassThrough } from "stream";
import { arrayBuffer } from "stream/consumers";
import { pipeline } from "stream/promises";
import { URL } from "url";
import zlib from "zlib";
import {
  Request,
  logResponse
} from "@miniflare/core";
import { randomHex } from "@miniflare/shared";
import { coupleWebSocket } from "@miniflare/web-sockets";
import { Headers } from "undici";
import { WebSocketServer } from "ws";

// packages/http-server/src/helpers.ts
import { networkInterfaces } from "os";
function getAccessibleHosts(ipv4 = false) {
  const hosts = [];
  Object.values(networkInterfaces()).forEach((net) => net?.forEach(({ family, address }) => {
    if (!ipv4 || family === "IPv4")
      hosts.push(address);
  }));
  return hosts;
}

// packages/http-server/src/plugin.ts
import fs from "fs/promises";
import path from "path";
import { promisify } from "util";
import {
  Option,
  OptionType,
  Plugin,
  defaultClock
} from "@miniflare/shared";
import { fetch } from "undici";
var DAY = 864e5;
var CERT_DAYS = 30;
var CF_DAYS = 30;
var defaultCertRoot = path.resolve(".mf", "cert");
var defaultCfPath = path.resolve("node_modules", ".mf", "cf.json");
var defaultCfFetch = process.env.NODE_ENV !== "test";
var defaultCfFetchEndpoint = "https://workers.cloudflare.com/cf.json";
var defaultCf = {
  asn: 395747,
  colo: "DFW",
  city: "Austin",
  region: "Texas",
  regionCode: "TX",
  metroCode: "635",
  postalCode: "78701",
  country: "US",
  continent: "NA",
  timezone: "America/Chicago",
  latitude: "30.27130",
  longitude: "-97.74260",
  clientTcpRtt: 0,
  httpProtocol: "HTTP/1.1",
  requestPriority: "weight=192;exclusive=0",
  tlsCipher: "AEAD-AES128-GCM-SHA256",
  tlsVersion: "TLSv1.3",
  tlsClientAuth: {
    certIssuerDNLegacy: "",
    certIssuerDN: "",
    certPresented: "0",
    certSubjectDNLegacy: "",
    certSubjectDN: "",
    certNotBefore: "",
    certNotAfter: "",
    certSerial: "",
    certFingerprintSHA1: "",
    certVerified: "NONE"
  }
};
function valueOrFile(value, filePath) {
  return value ?? (filePath && fs.readFile(filePath, "utf8"));
}
var HTTPPlugin = class extends Plugin {
  constructor(ctx, options, defaults = {}) {
    super(ctx);
    this.defaults = defaults;
    this.assignOptions(options);
    this.defaultCertRoot = defaults.certRoot ?? defaultCertRoot;
    this.defaultCfPath = defaults.cfPath ?? defaultCfPath;
    this.defaultCfFetch = defaults.cfFetch ?? defaultCfFetch;
    this.cfFetchEndpoint = defaults.cfFetchEndpoint ?? defaultCfFetchEndpoint;
    this.clock = defaults.clock ?? defaultClock;
    this.httpsEnabled = !!(this.https || this.httpsKey || this.httpsKeyPath || this.httpsCert || this.httpsCertPath || this.httpsCa || this.httpsCaPath || this.httpsPfx || this.httpsPfxPath);
  }
  host;
  port;
  https;
  httpsKey;
  httpsKeyPath;
  httpsCert;
  httpsCertPath;
  httpsCa;
  httpsCaPath;
  httpsPfx;
  httpsPfxPath;
  httpsPassphrase;
  cfFetch;
  metaProvider;
  liveReload;
  defaultCertRoot;
  defaultCfPath;
  defaultCfFetch;
  cfFetchEndpoint;
  clock;
  #cf = defaultCf;
  httpsEnabled;
  #httpsOptions;
  getRequestMeta(req) {
    if (this.metaProvider)
      return this.metaProvider(req);
    return { cf: this.#cf };
  }
  get httpsOptions() {
    return this.#httpsOptions;
  }
  async setupCf() {
    let cfPath = this.cfFetch ?? this.defaultCfFetch;
    if (!cfPath || this.metaProvider)
      return;
    if (cfPath === true)
      cfPath = this.defaultCfPath;
    let refetch = true;
    try {
      this.#cf = JSON.parse(await fs.readFile(cfPath, "utf8"));
      const cfStat = await fs.stat(cfPath);
      refetch = this.clock() - cfStat.mtimeMs > CF_DAYS * DAY;
    } catch {
    }
    if (!refetch)
      return;
    try {
      const res = await fetch(this.cfFetchEndpoint);
      const cfText = await res.text();
      this.#cf = JSON.parse(cfText);
      await fs.mkdir(path.dirname(cfPath), { recursive: true });
      await fs.writeFile(cfPath, cfText, "utf8");
      this.ctx.log.info("Updated Request cf object cache!");
    } catch (e) {
      this.ctx.log.error(e);
    }
  }
  async setupHttps() {
    if (!this.httpsEnabled)
      return;
    let https2 = this.https;
    if (https2 === true)
      https2 = this.defaultCertRoot;
    if (typeof https2 === "string") {
      const keyPath = path.join(https2, "key.pem");
      const certPath = path.join(https2, "cert.pem");
      let regenerate = true;
      try {
        const keyStat = await fs.stat(keyPath);
        const certStat = await fs.stat(certPath);
        const created = Math.max(keyStat.mtimeMs, certStat.mtimeMs);
        regenerate = this.clock() - created > (CERT_DAYS - 2) * DAY;
      } catch {
      }
      if (regenerate) {
        this.ctx.log.info("Generating new self-signed certificate...");
        const selfSigned = await import("selfsigned");
        const certAttrs = [
          { name: "commonName", value: "localhost" }
        ];
        const certOptions = {
          algorithm: "sha256",
          days: CERT_DAYS,
          keySize: 2048,
          extensions: [
            { name: "basicConstraints", cA: true },
            {
              name: "keyUsage",
              keyCertSign: true,
              digitalSignature: true,
              nonRepudiation: true,
              keyEncipherment: true,
              dataEncipherment: true
            },
            {
              name: "extKeyUsage",
              serverAuth: true,
              clientAuth: true,
              codeSigning: true,
              timeStamping: true
            },
            {
              name: "subjectAltName",
              altNames: [
                { type: 2, value: "localhost" },
                ...getAccessibleHosts().map((ip) => ({ type: 7, ip }))
              ]
            }
          ]
        };
        const cert = await promisify(selfSigned.generate)(certAttrs, certOptions);
        await fs.mkdir(https2, { recursive: true });
        await fs.writeFile(keyPath, cert.private, "utf8");
        await fs.writeFile(certPath, cert.cert, "utf8");
      }
      this.httpsKeyPath = keyPath;
      this.httpsCertPath = certPath;
    }
    this.#httpsOptions = {
      key: await valueOrFile(this.httpsKey, this.httpsKeyPath),
      cert: await valueOrFile(this.httpsCert, this.httpsCertPath),
      ca: await valueOrFile(this.httpsCa, this.httpsCaPath),
      pfx: await valueOrFile(this.httpsPfx, this.httpsPfxPath),
      passphrase: this.httpsPassphrase
    };
  }
  async setup() {
    void this.setupCf();
    await this.setupHttps();
    return {};
  }
};
__decorateClass([
  Option({
    type: OptionType.STRING,
    alias: "H",
    description: "Host for HTTP(S) server to listen on",
    fromWrangler: ({ miniflare }) => miniflare?.host
  })
], HTTPPlugin.prototype, "host", 2);
__decorateClass([
  Option({
    type: OptionType.NUMBER,
    alias: "p",
    description: "Port for HTTP(S) server to listen on",
    fromWrangler: ({ miniflare }) => miniflare?.port
  })
], HTTPPlugin.prototype, "port", 2);
__decorateClass([
  Option({
    type: OptionType.BOOLEAN_STRING,
    description: "Enable self-signed HTTPS (with optional cert path)",
    logName: "HTTPS",
    fromWrangler: ({ miniflare }) => typeof miniflare?.https === "object" ? void 0 : miniflare?.https
  })
], HTTPPlugin.prototype, "https", 2);
__decorateClass([
  Option({ type: OptionType.NONE })
], HTTPPlugin.prototype, "httpsKey", 2);
__decorateClass([
  Option({
    type: OptionType.STRING,
    name: "https-key",
    description: "Path to PEM SSL key",
    logName: "HTTPS Key",
    fromWrangler: ({ miniflare }) => typeof miniflare?.https === "object" ? miniflare.https?.key : void 0
  })
], HTTPPlugin.prototype, "httpsKeyPath", 2);
__decorateClass([
  Option({ type: OptionType.NONE })
], HTTPPlugin.prototype, "httpsCert", 2);
__decorateClass([
  Option({
    type: OptionType.STRING,
    name: "https-cert",
    description: "Path to PEM SSL cert chain",
    logName: "HTTPS Cert",
    fromWrangler: ({ miniflare }) => typeof miniflare?.https === "object" ? miniflare.https?.cert : void 0
  })
], HTTPPlugin.prototype, "httpsCertPath", 2);
__decorateClass([
  Option({ type: OptionType.NONE })
], HTTPPlugin.prototype, "httpsCa", 2);
__decorateClass([
  Option({
    type: OptionType.STRING,
    name: "https-ca",
    description: "Path to SSL trusted CA certs",
    logName: "HTTPS CA",
    fromWrangler: ({ miniflare }) => typeof miniflare?.https === "object" ? miniflare.https?.ca : void 0
  })
], HTTPPlugin.prototype, "httpsCaPath", 2);
__decorateClass([
  Option({ type: OptionType.NONE })
], HTTPPlugin.prototype, "httpsPfx", 2);
__decorateClass([
  Option({
    type: OptionType.STRING,
    name: "https-pfx",
    description: "Path to PFX/PKCS12 SSL key/cert chain",
    logName: "HTTPS PFX",
    fromWrangler: ({ miniflare }) => typeof miniflare?.https === "object" ? miniflare.https?.pfx : void 0
  })
], HTTPPlugin.prototype, "httpsPfxPath", 2);
__decorateClass([
  Option({
    type: OptionType.STRING,
    description: "Passphrase to decrypt SSL files",
    logName: "HTTPS Passphrase",
    logValue: () => "**********",
    fromWrangler: ({ miniflare }) => typeof miniflare?.https === "object" ? miniflare.https?.passphrase : void 0
  })
], HTTPPlugin.prototype, "httpsPassphrase", 2);
__decorateClass([
  Option({
    type: OptionType.BOOLEAN_STRING,
    description: "Path for cached Request cf object from Cloudflare",
    negatable: true,
    logName: "Request cf Object Fetch",
    logValue(value) {
      if (value === true)
        return path.relative("", defaultCfPath);
      if (value === false)
        return void 0;
      return path.relative("", value);
    },
    fromWrangler: ({ miniflare }) => miniflare?.cf_fetch
  })
], HTTPPlugin.prototype, "cfFetch", 2);
__decorateClass([
  Option({ type: OptionType.NONE })
], HTTPPlugin.prototype, "metaProvider", 2);
__decorateClass([
  Option({
    type: OptionType.BOOLEAN,
    description: "Reload HTML pages whenever worker is reloaded",
    fromWrangler: ({ miniflare }) => miniflare?.live_reload
  })
], HTTPPlugin.prototype, "liveReload", 2);

// packages/http-server/src/index.ts
var liveReloadScript = `<script defer type="application/javascript">
(function () {
  // Miniflare Live Reload
  var url = new URL("/cdn-cgi/mf/reload", location.origin);
  url.protocol = url.protocol.replace("http", "ws");
  function reload() { location.reload(); }
  function connect(reconnected) {
    var ws = new WebSocket(url);
    if (reconnected) ws.onopen = reload;
    ws.onclose = function(e) {
      e.code === 1012 ? reload() : e.code === 1000 || e.code === 1001 || setTimeout(connect, 1000, true);
    }
  }
  connect();
})();
<\/script>`;
var liveReloadScriptLength = Buffer.byteLength(liveReloadScript);
async function convertNodeRequest(req, upstream, meta) {
  const url = new URL(req.url ?? "", upstream ?? `http://${req.headers.host}`);
  let body = null;
  if (req.method !== "GET" && req.method !== "HEAD") {
    if (req.headers["transfer-encoding"]?.includes("chunked")) {
      body = req;
    } else if (req.headers["content-length"] !== "0") {
      body = await arrayBuffer(req);
    }
  }
  const proto = meta?.forwardedProto ?? "https";
  let ip = meta?.realIp ?? req.socket.remoteAddress ?? "";
  if (ip === "::1")
    ip = "127.0.0.1";
  if (ip.startsWith("::ffff:"))
    ip = ip.substring("::ffff:".length);
  req.headers["x-forwarded-proto"] ??= proto;
  req.headers["x-real-ip"] ??= ip;
  req.headers["cf-connecting-ip"] ??= ip;
  req.headers["cf-ipcountry"] ??= meta?.cf?.country ?? "US";
  req.headers["cf-ray"] ??= randomHex(16);
  req.headers["cf-visitor"] ??= `{"scheme":"${proto}"}`;
  req.headers["host"] = url.host;
  const headers = new Headers();
  for (const [name, values] of Object.entries(req.headers)) {
    if (name === "transfer-encoding" || name === "connection" || name === "keep-alive" || name === "expect") {
      continue;
    }
    if (Array.isArray(values)) {
      for (const value of values)
        headers.append(name, value);
    } else if (values !== void 0) {
      headers.append(name, values);
    }
  }
  const request = new Request(url, {
    method: req.method,
    headers,
    body,
    cf: meta?.cf
  });
  return { request, url };
}
function createRequestListener(mf) {
  return async (req, res) => {
    const { CorePlugin, HTTPPlugin: HTTPPlugin2 } = await mf.getPlugins();
    const start = process.hrtime();
    const { request, url } = await convertNodeRequest(req, CorePlugin.upstream, await HTTPPlugin2.getRequestMeta(req));
    let response;
    let waitUntil;
    let status = 500;
    const pathname = url.pathname.replace(/\/$/, "");
    if (pathname.startsWith("/cdn-cgi/")) {
      if (pathname === "/cdn-cgi/mf/scheduled") {
        req.method = "SCHD";
        const time = url.searchParams.get("time");
        const cron = url.searchParams.get("cron");
        waitUntil = mf.dispatchScheduled(time ? parseInt(time) : void 0, cron ?? void 0);
        status = 200;
      } else {
        status = 404;
      }
      res?.writeHead(status, { "Content-Type": "text/plain; charset=UTF-8" });
      res?.end();
    } else {
      try {
        response = await mf.dispatchFetch(request);
        waitUntil = response.waitUntil();
        status = response.status;
        const headers = {};
        for (let [key, value] of response.headers) {
          key = key.toLowerCase();
          if (key === "set-cookie") {
            headers["set-cookie"] = response.headers.getAll("set-cookie");
          } else {
            headers[key] = value;
          }
        }
        const encoders = [];
        if (headers["content-encoding"] && response.encodeBody === "auto") {
          delete headers["content-length"];
          const codings = headers["content-encoding"].toString().toLowerCase().split(",").map((x) => x.trim());
          for (const coding of codings) {
            if (/(x-)?gzip/.test(coding)) {
              encoders.push(zlib.createGzip());
            } else if (/(x-)?deflate/.test(coding)) {
              encoders.push(zlib.createDeflate());
            } else if (coding === "br") {
              encoders.push(zlib.createBrotliCompress());
            } else {
              mf.log.warn(`Unknown encoding "${coding}", sending plain response...`);
              delete headers["content-encoding"];
              encoders.length = 0;
              break;
            }
          }
        }
        const liveReloadEnabled = HTTPPlugin2.liveReload && response.encodeBody === "auto" && response.headers.get("content-type")?.toLowerCase().includes("text/html");
        const contentLength = response.headers.get("content-length");
        if (liveReloadEnabled && contentLength !== null) {
          const length = parseInt(contentLength);
          if (!isNaN(length)) {
            headers["content-length"] = length + liveReloadScriptLength;
          }
        }
        res?.writeHead(status, headers);
        if (res) {
          const passThrough = new PassThrough();
          const pipelinePromise = pipeline(passThrough, ...encoders, res);
          if (response.body) {
            for await (const chunk of response.body) {
              if (chunk)
                passThrough.write(chunk);
            }
            if (liveReloadEnabled) {
              passThrough.write(liveReloadScript);
            }
          }
          passThrough.end();
          await pipelinePromise;
        }
      } catch (e) {
        const accept = req.headers.accept?.toLowerCase() ?? "";
        if (accept.includes("text/html") || accept.includes("*/*") || accept.includes("text/*")) {
          const { default: Youch } = await import("youch");
          const youch = new Youch(e, req);
          youch.addLink(() => {
            const links = [
              '<a href="https://developers.cloudflare.com/workers/" target="_blank" style="text-decoration:none">\u{1F4DA} Workers Docs</a>',
              '<a href="https://discord.gg/cloudflaredev" target="_blank" style="text-decoration:none">\u{1F4AC} Workers Discord</a>',
              '<a href="https://miniflare.dev" target="_blank" style="text-decoration:none">\u{1F525} Miniflare Docs</a>'
            ];
            if (HTTPPlugin2.liveReload)
              links.push(liveReloadScript);
            return links.join("");
          });
          const errorHtml = await youch.toHTML();
          res?.writeHead(500, { "Content-Type": "text/html; charset=UTF-8" });
          res?.end(errorHtml, "utf8");
        } else {
          res?.writeHead(500, { "Content-Type": "text/plain; charset=UTF-8" });
          res?.end(e.stack, "utf8");
        }
        const proxiedError = new Proxy(e, {
          get(target, propertyKey, receiver) {
            const value = Reflect.get(target, propertyKey, receiver);
            return propertyKey === "stack" ? `${req.method} ${req.url}: ${value}` : value;
          }
        });
        mf.log.error(proxiedError);
      }
    }
    assert(req.method && req.url);
    await logResponse(mf.log, {
      start,
      method: req.method,
      url: req.url,
      status,
      waitUntil
    });
    return response;
  };
}
async function createServer(mf, options) {
  const plugins = await mf.getPlugins();
  const listener = createRequestListener(mf);
  let server;
  if (plugins.HTTPPlugin.httpsEnabled) {
    const httpsOptions = plugins.HTTPPlugin.httpsOptions;
    assert(httpsOptions);
    server = https.createServer({ ...httpsOptions, ...options }, listener);
  } else {
    server = http.createServer(options ?? {}, listener);
  }
  const webSocketServer = new WebSocketServer({ noServer: true });
  const liveReloadServer = new WebSocketServer({ noServer: true });
  server.on("upgrade", async (request, socket, head) => {
    const { pathname } = new URL(request.url ?? "", "http://localhost");
    if (pathname === "/cdn-cgi/mf/reload") {
      liveReloadServer.handleUpgrade(request, socket, head, (ws) => {
        liveReloadServer.emit("connection", ws, request);
      });
    } else {
      const response = await listener(request);
      const webSocket = response?.webSocket;
      if (response?.status !== 101 || !webSocket) {
        socket.write("HTTP/1.1 500 Internal Server Error\r\n\r\n");
        socket.destroy();
        mf.log.error(new TypeError("Web Socket request did not return status 101 Switching Protocols response with Web Socket"));
        return;
      }
      webSocketServer.handleUpgrade(request, socket, head, (ws) => {
        void coupleWebSocket(ws, webSocket);
        webSocketServer.emit("connection", ws, request);
      });
    }
  });
  const reloadListener = () => {
    for (const ws of liveReloadServer.clients) {
      ws.close(1012, "Service Restart");
    }
    for (const ws of webSocketServer.clients) {
      ws.close(1012, "Service Restart");
    }
  };
  mf.addEventListener("reload", reloadListener);
  server.on("close", () => mf.removeEventListener("reload", reloadListener));
  return server;
}
async function startServer(mf, options) {
  const server = await createServer(mf, options);
  const plugins = await mf.getPlugins();
  const { httpsEnabled, host, port = 8787 } = plugins.HTTPPlugin;
  return new Promise((resolve) => {
    server.listen(port, host, () => {
      const log = mf.log;
      const protocol = httpsEnabled ? "https" : "http";
      const accessibleHosts = host ? [host] : getAccessibleHosts(true);
      log.info(`Listening on ${host ?? ""}:${port}`);
      for (const accessibleHost of accessibleHosts) {
        log.info(`- ${protocol}://${accessibleHost}:${port}`);
      }
      resolve(server);
    });
  });
}
export {
  HTTPPlugin,
  convertNodeRequest,
  createRequestListener,
  createServer,
  getAccessibleHosts,
  startServer
};
//# sourceMappingURL=index.js.map
