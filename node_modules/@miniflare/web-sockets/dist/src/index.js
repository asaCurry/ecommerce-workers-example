// packages/web-sockets/src/fetch.ts
import { URL } from "url";
import {
  Request,
  Response,
  fetch
} from "@miniflare/core";
import StandardWebSocket2 from "ws";

// packages/web-sockets/src/couple.ts
import { viewToBuffer } from "@miniflare/shared";
import StandardWebSocket from "ws";

// packages/web-sockets/src/websocket.ts
import assert from "assert";
import {
  InputGatedEventTarget,
  waitForOpenOutputGate
} from "@miniflare/shared";
var MessageEvent = class extends Event {
  constructor(data) {
    super("message");
    this.data = data;
  }
};
var CloseEvent = class extends Event {
  constructor(code = 1005, reason, wasClean = false) {
    super("close");
    this.code = code;
    this.reason = reason;
    this.wasClean = wasClean;
  }
};
var ErrorEvent = class extends Event {
  constructor(error) {
    super("error");
    this.error = error;
  }
};
var kPair = Symbol("kPair");
var kAccepted = Symbol("kAccepted");
var kCoupled = Symbol("kCoupled");
var kClosed = Symbol("kClosed");
var kClose = Symbol("kClose");
var WebSocket = class extends InputGatedEventTarget {
  #sendQueue = [];
  [kPair];
  [kAccepted] = false;
  [kCoupled] = false;
  [kClosed] = false;
  accept() {
    if (this[kCoupled]) {
      throw new TypeError("Can't accept() WebSocket that was already used in a response.");
    }
    if (this[kAccepted])
      return;
    this[kAccepted] = true;
    const sendQueue = this.#sendQueue;
    if (sendQueue) {
      for (const event of sendQueue)
        this.dispatchEvent(event);
      this.#sendQueue = void 0;
    }
  }
  send(message) {
    if (!this[kAccepted]) {
      throw new TypeError("You must call accept() on this WebSocket before sending messages.");
    }
    if (this[kClosed]) {
      throw new TypeError("Can't call WebSocket send() after close().");
    }
    const event = new MessageEvent(message);
    void this.#dispatchMessageEvent(event);
  }
  async #dispatchMessageEvent(event) {
    await waitForOpenOutputGate();
    const pair = this[kPair];
    if (pair[kAccepted]) {
      pair.dispatchEvent(event);
    } else {
      const sendQueue = pair.#sendQueue;
      assert(sendQueue !== void 0);
      sendQueue.push(event);
    }
  }
  close(code, reason) {
    if (code) {
      const validCode = code >= 1e3 && code < 5e3 && code !== 1004 && code !== 1005 && code !== 1006 && code !== 1015;
      if (!validCode)
        throw new TypeError("Invalid WebSocket close code.");
    }
    if (reason !== void 0 && code === void 0) {
      throw new TypeError("If you specify a WebSocket close reason, you must also specify a code.");
    }
    this[kClose](code, reason);
  }
  [kClose](code, reason) {
    if (!this[kAccepted]) {
      throw new TypeError("You must call accept() on this WebSocket before sending messages.");
    }
    if (this[kClosed])
      throw new TypeError("WebSocket already closed");
    this[kClosed] = true;
    this[kPair][kClosed] = true;
    void this.#dispatchCloseEvent(code, reason);
  }
  async #dispatchCloseEvent(code, reason) {
    await waitForOpenOutputGate();
    this.dispatchEvent(new CloseEvent(code, reason));
    this[kPair].dispatchEvent(new CloseEvent(code, reason));
  }
};
var WebSocketPair = function() {
  if (!(this instanceof WebSocketPair)) {
    throw new TypeError("Failed to construct 'WebSocketPair': Please use the 'new' operator, this object constructor cannot be called as a function.");
  }
  this[0] = new WebSocket();
  this[1] = new WebSocket();
  this[0][kPair] = this[1];
  this[1][kPair] = this[0];
};

// packages/web-sockets/src/couple.ts
async function coupleWebSocket(ws, pair) {
  if (pair[kCoupled]) {
    throw new TypeError("Can't return WebSocket that was already used in a response.");
  }
  if (pair[kAccepted]) {
    throw new TypeError("Can't return WebSocket in a Response after calling accept().");
  }
  ws.on("message", (message, isBinary) => {
    if (isBinary) {
      pair.send(viewToBuffer(message));
    } else {
      pair.send(message.toString());
    }
  });
  ws.on("close", (code, reason) => {
    if (!pair[kClosed])
      pair[kClose](code, reason.toString());
  });
  ws.on("error", (error) => {
    pair.dispatchEvent(new ErrorEvent(error));
  });
  pair.addEventListener("message", (e) => {
    ws.send(e.data);
  });
  pair.addEventListener("close", (e) => {
    if (ws.readyState < StandardWebSocket.CLOSING)
      ws.close(e.code, e.reason);
  });
  if (ws.readyState === StandardWebSocket.CONNECTING) {
    await new Promise((resolve, reject) => {
      ws.once("open", () => {
        pair.accept();
        pair[kCoupled] = true;
        ws.off("close", reject);
        ws.off("error", reject);
        resolve();
      });
      ws.once("close", reject);
      ws.once("error", reject);
    });
  } else {
    pair.accept();
    pair[kCoupled] = true;
    if (ws.readyState >= StandardWebSocket.CLOSING) {
      throw new TypeError("Incoming WebSocket connection already closed.");
    }
  }
}

// packages/web-sockets/src/fetch.ts
async function upgradingFetch(input, init) {
  const request = new Request(input, init);
  if (request.method === "GET" && request.headers.get("upgrade") === "websocket") {
    const headers = {};
    for (const [key, value] of request.headers.entries()) {
      headers[key] = value;
    }
    const url = new URL(request.url);
    if (url.protocol !== "http:" && url.protocol !== "https:") {
      throw new TypeError(`Fetch API cannot load: ${url.toString()}.
Make sure you're using http(s):// URLs for WebSocket requests via fetch.`);
    }
    url.protocol = url.protocol.replace("http", "ws");
    const ws = new StandardWebSocket2(url, {
      followRedirects: request.redirect === "follow",
      headers
    });
    const [worker, client] = Object.values(new WebSocketPair());
    await coupleWebSocket(ws, client);
    return new Response(null, {
      status: 101,
      webSocket: worker
    });
  }
  return fetch(request);
}

// packages/web-sockets/src/plugin.ts
import {
  createCompatFetch
} from "@miniflare/core";
import { Plugin } from "@miniflare/shared";
var constructError = "Failed to construct 'WebSocket': the constructor is not implemented.";
var WebSocketPlugin = class extends Plugin {
  #webSockets = new Set();
  #upgradingFetch;
  constructor(ctx) {
    super(ctx);
    this.#upgradingFetch = createCompatFetch(ctx.compat, upgradingFetch);
  }
  setup() {
    return {
      globals: {
        MessageEvent,
        CloseEvent,
        WebSocketPair,
        WebSocket: new Proxy(WebSocket, {
          construct() {
            throw new Error(constructError);
          },
          apply() {
            throw new Error(constructError);
          }
        }),
        fetch: this.fetch
      }
    };
  }
  fetch = async (input, init) => {
    const response = await this.#upgradingFetch(input, init);
    if (response.webSocket)
      this.#webSockets.add(response.webSocket);
    return response;
  };
  reload() {
    for (const ws of this.#webSockets) {
      if (!ws[kClosed])
        ws.close(1012, "Service Restart");
    }
    this.#webSockets.clear();
  }
  dispose() {
    return this.reload();
  }
};
export {
  CloseEvent,
  ErrorEvent,
  MessageEvent,
  WebSocket,
  WebSocketPair,
  WebSocketPlugin,
  coupleWebSocket,
  upgradingFetch
};
//# sourceMappingURL=index.js.map
