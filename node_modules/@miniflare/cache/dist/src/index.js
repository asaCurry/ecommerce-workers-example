var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __decorateClass = (decorators, target, key, kind) => {
  var result = kind > 1 ? void 0 : kind ? __getOwnPropDesc(target, key) : target;
  for (var i = decorators.length - 1, decorator; i >= 0; i--)
    if (decorator = decorators[i])
      result = (kind ? decorator(target, key, result) : decorator(result)) || result;
  if (kind && result)
    __defProp(target, key, result);
  return result;
};

// packages/cache/src/cache.ts
import { URL } from "url";
import {
  Request,
  Response,
  withStringFormDataFiles
} from "@miniflare/core";
import {
  defaultClock,
  millisToSeconds,
  waitForOpenInputGate,
  waitForOpenOutputGate
} from "@miniflare/shared";
import CachePolicy from "http-cache-semantics";
import {
  Request as BaseRequest,
  Headers
} from "undici";
function normaliseRequest(req) {
  return req instanceof Request || req instanceof BaseRequest ? req : new Request(req);
}
function normaliseHeaders(headers) {
  const result = {};
  for (const [key, value] of headers)
    result[key.toLowerCase()] = value;
  return result;
}
function getKey(req) {
  if (req.cf?.cacheKey)
    return req.cf.cacheKey;
  try {
    const url = new URL(req.url);
    return url.toString();
  } catch (e) {
    throw new TypeError("Invalid URL. Cache API keys must be fully-qualified, valid URLs.");
  }
}
var cacheTtlByStatusRangeRegexp = /^(?<from>\d+)(-(?<to>\d+))?$/;
function getExpirationTtl(clock, req, res) {
  const cf = req.cf;
  if (cf?.cacheTtl)
    return cf.cacheTtl * 1e3;
  if (cf?.cacheTtlByStatus) {
    for (const [range, ttl] of Object.entries(cf.cacheTtlByStatus)) {
      const match = cacheTtlByStatusRangeRegexp.exec(range);
      const fromString = match?.groups?.from;
      if (!fromString)
        continue;
      const from = parseInt(fromString);
      const toString = match?.groups?.to;
      if (toString) {
        const to = parseInt(toString);
        if (from <= res.status && res.status <= to)
          return ttl * 1e3;
      } else if (res.status === from) {
        return ttl * 1e3;
      }
    }
  }
  const reqHeaders = normaliseHeaders(req.headers);
  delete reqHeaders["cache-control"];
  const resHeaders = normaliseHeaders(res.headers);
  if (resHeaders["cache-control"]?.toLowerCase().includes("private=set-cookie")) {
    resHeaders["cache-control"] = resHeaders["cache-control"].replace(/private=set-cookie/i, "");
    delete resHeaders["set-cookie"];
  }
  const cacheReq = {
    url: req.url,
    method: req.method,
    headers: reqHeaders
  };
  const cacheRes = {
    status: res.status,
    headers: resHeaders
  };
  const originalNow = CachePolicy.prototype.now;
  CachePolicy.prototype.now = clock;
  try {
    const policy = new CachePolicy(cacheReq, cacheRes, { shared: true });
    if ("set-cookie" in resHeaders || !policy.storable()) {
      return;
    }
    return policy.timeToLive();
  } finally {
    CachePolicy.prototype.now = originalNow;
  }
}
var Cache = class {
  #storage;
  #formDataFiles;
  #clock;
  constructor(storage, formDataFiles = true, clock = defaultClock) {
    this.#storage = storage;
    this.#formDataFiles = formDataFiles;
    this.#clock = clock;
  }
  async put(req, res) {
    req = normaliseRequest(req);
    if (res instanceof Response && res.webSocket) {
      throw new TypeError("Cannot cache WebSocket upgrade response.");
    }
    if (req.method !== "GET") {
      throw new TypeError("Cannot cache response to non-GET request.");
    }
    if (res.status === 206) {
      throw new TypeError("Cannot cache response to a range request (206 Partial Content).");
    }
    if (res.headers.get("vary")?.includes("*")) {
      throw new TypeError("Cannot cache response with 'Vary: *' header.");
    }
    const expirationTtl = getExpirationTtl(this.#clock, req, res);
    if (expirationTtl === void 0)
      return;
    const key = getKey(req);
    const metadata = {
      status: res.status,
      headers: [...res.headers]
    };
    const storage = await this.#storage;
    await waitForOpenOutputGate();
    await storage.put(key, {
      value: new Uint8Array(await res.arrayBuffer()),
      expiration: millisToSeconds(this.#clock() + expirationTtl),
      metadata
    });
    await waitForOpenInputGate();
  }
  async match(req, options) {
    req = normaliseRequest(req);
    if (req.method !== "GET" && !options?.ignoreMethod)
      return;
    const key = getKey(req);
    const storage = await this.#storage;
    const cached = await storage.get(key);
    await waitForOpenInputGate();
    if (!cached)
      return;
    const headers = new Headers(cached.metadata?.headers);
    headers.set("CF-Cache-Status", "HIT");
    let res = new Response(cached.value, {
      status: cached.metadata?.status,
      headers
    });
    if (!this.#formDataFiles)
      res = withStringFormDataFiles(res);
    return res;
  }
  async delete(req, options) {
    req = normaliseRequest(req);
    if (req.method !== "GET" && !options?.ignoreMethod)
      return false;
    const key = getKey(req);
    const storage = await this.#storage;
    await waitForOpenOutputGate();
    const result = storage.delete(key);
    await waitForOpenInputGate();
    return result;
  }
};

// packages/cache/src/noop.ts
var NoOpCache = class {
  async put(_req, _res) {
    return;
  }
  async match(_req, _options) {
    return;
  }
  async delete(_req, _options) {
    return false;
  }
};

// packages/cache/src/plugin.ts
import {
  MiniflareError,
  Option,
  OptionType,
  Plugin
} from "@miniflare/shared";
var DEFAULT_CACHE_NAME = "default";
var MAX_CACHE_NAME_SIZE = 1024;
var NOOP_CACHE = new NoOpCache();
var CacheError = class extends MiniflareError {
};
var CacheStorage = class {
  #options;
  #log;
  #storage;
  #formDataFiles;
  #warnUsage;
  #defaultCache;
  constructor(options, log, storageFactory, formDataFiles = true) {
    this.#options = options;
    this.#log = log;
    this.#storage = storageFactory;
    this.#formDataFiles = formDataFiles;
    this.#warnUsage = options.cacheWarnUsage;
  }
  #maybeWarnUsage() {
    if (!this.#warnUsage)
      return;
    this.#warnUsage = false;
    this.#log.warn("Cache operations will have no impact if you deploy to a workers.dev subdomain!");
  }
  get default() {
    const defaultCache = this.#defaultCache;
    if (defaultCache)
      return defaultCache;
    const { cache, cachePersist } = this.#options;
    if (cache === false)
      return NOOP_CACHE;
    this.#maybeWarnUsage();
    return this.#defaultCache = new Cache(this.#storage.storage(DEFAULT_CACHE_NAME, cachePersist), this.#formDataFiles);
  }
  async open(cacheName) {
    if (cacheName === DEFAULT_CACHE_NAME) {
      throw new CacheError("ERR_RESERVED", `"${cacheName}" is a reserved cache name`);
    }
    if (cacheName.length > MAX_CACHE_NAME_SIZE) {
      throw new TypeError("Cache name is too long.");
    }
    const { cache, cachePersist } = this.#options;
    if (cache === false)
      return NOOP_CACHE;
    this.#maybeWarnUsage();
    return new Cache(await this.#storage.storage(cacheName, cachePersist), this.#formDataFiles);
  }
};
var CachePlugin = class extends Plugin {
  cache;
  cachePersist;
  cacheWarnUsage;
  #caches;
  constructor(ctx, options) {
    super(ctx);
    this.assignOptions(options);
  }
  setup(storageFactory) {
    this.#caches = new CacheStorage(this, this.ctx.log, storageFactory, this.ctx.compat.isEnabled("formdata_parser_supports_files"));
    return { globals: { caches: this.#caches } };
  }
  getCaches() {
    return this.#caches;
  }
};
__decorateClass([
  Option({
    type: OptionType.BOOLEAN,
    description: "Enable default/named caches (enabled by default)",
    negatable: true,
    logName: "Cache",
    fromWrangler: ({ miniflare }) => miniflare?.cache
  })
], CachePlugin.prototype, "cache", 2);
__decorateClass([
  Option({
    type: OptionType.BOOLEAN_STRING,
    description: "Persist cached data (to optional path)",
    logName: "Cache Persistence",
    fromWrangler: ({ miniflare }) => miniflare?.cache_persist
  })
], CachePlugin.prototype, "cachePersist", 2);
__decorateClass([
  Option({
    type: OptionType.NONE,
    fromWrangler: ({ workers_dev }) => workers_dev
  })
], CachePlugin.prototype, "cacheWarnUsage", 2);
export {
  Cache,
  CacheError,
  CachePlugin,
  CacheStorage,
  NoOpCache
};
//# sourceMappingURL=index.js.map
