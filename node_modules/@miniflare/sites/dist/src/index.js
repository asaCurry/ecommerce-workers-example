var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __decorateClass = (decorators, target, key, kind) => {
  var result = kind > 1 ? void 0 : kind ? __getOwnPropDesc(target, key) : target;
  for (var i = decorators.length - 1, decorator; i >= 0; i--)
    if (decorator = decorators[i])
      result = (kind ? decorator(target, key, result) : decorator(result)) || result;
  if (kind && result)
    __defProp(target, key, result);
  return result;
};

// packages/sites/src/filtered.ts
import {
  KVNamespace
} from "@miniflare/kv";
var FilteredKVNamespace = class extends KVNamespace {
  #options;
  constructor(storage, options = {}, clock) {
    super(storage, clock);
    this.#options = options;
  }
  #included(key) {
    const options = this.#options;
    if (options.include !== void 0)
      return options.include.test(key);
    if (options.exclude !== void 0)
      return !options.exclude.test(key);
    return true;
  }
  get(key, options) {
    if (!this.#included(key))
      return Promise.resolve(null);
    return super.get(key, options);
  }
  getWithMetadata(key, options) {
    if (!this.#included(key)) {
      return Promise.resolve({ value: null, metadata: null });
    }
    return super.getWithMetadata(key, options);
  }
  async put(key, value, options) {
    if (this.#options.readOnly) {
      throw new TypeError("Unable to put into read-only namespace");
    }
    return super.put(key, value, options);
  }
  async delete(key) {
    if (this.#options.readOnly) {
      throw new TypeError("Unable to delete from read-only namespace");
    }
    return super.delete(key);
  }
  async list(options) {
    const { keys, list_complete, cursor } = await super.list(options);
    return {
      keys: keys.filter((key) => this.#included(key.name)),
      list_complete,
      cursor
    };
  }
};

// packages/sites/src/plugin.ts
import path from "path";
import {
  Option,
  OptionType,
  Plugin,
  globsToMatcher
} from "@miniflare/shared";
var SitesPlugin = class extends Plugin {
  sitePath;
  siteInclude;
  siteExclude;
  #setupResult;
  constructor(ctx, options) {
    super(ctx);
    this.assignOptions(options);
    this.#setupResult = this.#setup();
  }
  async #setup() {
    if (!this.sitePath)
      return {};
    const { FileStorage } = await import("@miniflare/storage-file");
    const storage = new FileStorage(path.resolve(this.sitePath), false);
    const bindings = {
      __STATIC_CONTENT: new FilteredKVNamespace(storage, {
        readOnly: true,
        include: this.siteInclude && globsToMatcher(this.siteInclude),
        exclude: this.siteExclude && globsToMatcher(this.siteExclude)
      }),
      __STATIC_CONTENT_MANIFEST: {}
    };
    const additionalModules = {
      __STATIC_CONTENT_MANIFEST: { default: "{}" }
    };
    return { bindings, watch: [this.sitePath], additionalModules };
  }
  async setup() {
    return this.#setupResult;
  }
};
__decorateClass([
  Option({
    type: OptionType.STRING,
    name: "site",
    alias: "s",
    description: "Path to serve Workers Site files from",
    logName: "Workers Site Path",
    fromWrangler: ({ site }) => site?.bucket
  })
], SitesPlugin.prototype, "sitePath", 2);
__decorateClass([
  Option({
    type: OptionType.ARRAY,
    description: "Glob pattern of site files to serve",
    logName: "Workers Site Include",
    fromWrangler: ({ site }) => site?.include
  })
], SitesPlugin.prototype, "siteInclude", 2);
__decorateClass([
  Option({
    type: OptionType.ARRAY,
    description: "Glob pattern of site files not to serve",
    logName: "Workers Site Exclude",
    fromWrangler: ({ site }) => site?.exclude
  })
], SitesPlugin.prototype, "siteExclude", 2);
export {
  FilteredKVNamespace,
  SitesPlugin
};
//# sourceMappingURL=index.js.map
