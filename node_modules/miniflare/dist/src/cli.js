#!/usr/bin/env node

// packages/miniflare/src/cli.ts
import fs2 from "fs/promises";
import path from "path";
import { fileURLToPath } from "url";
import { red } from "kleur/colors";

// packages/miniflare/src/updater.ts
import fs from "fs/promises";
import semiver from "semiver";
import { fetch } from "undici";
var numericCompare = new Intl.Collator(void 0, { numeric: true }).compare;
async function updateCheck({
  pkg,
  lastCheckFile,
  log,
  now = Date.now(),
  registry = "https://registry.npmjs.org/"
}) {
  let lastCheck = 0;
  try {
    lastCheck = parseInt(await fs.readFile(lastCheckFile, "utf8"));
  } catch {
  }
  if (now - lastCheck < 864e5)
    return;
  const res = await fetch(`${registry}${pkg.name}/latest`, {
    headers: { Accept: "application/json" }
  });
  const registryVersion = (await res.json()).version;
  if (!registryVersion)
    return;
  await fs.writeFile(lastCheckFile, now.toString(), "utf8");
  if (semiver(registryVersion, pkg.version) > 0) {
    log.warn(`Miniflare ${registryVersion} is available, but you're using ${pkg.version}. Update for improved compatibility with Cloudflare Workers.`);
    const registryMajor = registryVersion.split(".")[0];
    const pkgMajor = pkg.version.split(".")[0];
    if (numericCompare(registryMajor, pkgMajor) > 0) {
      log.warn(`${registryVersion} includes breaking changes.Make sure you check the changelog before upgrading.`);
    }
  }
}

// packages/miniflare/src/cli.ts
var __filename = fileURLToPath(import.meta.url);
var __dirname = path.dirname(__filename);
function suppressWarnings() {
  const originalEmitWarning = process.emitWarning;
  process.emitWarning = (warning, ctorTypeOptions, ctorCode, ctor) => {
    if (ctorTypeOptions === "ExperimentalWarning") {
      const warningString = warning.toString();
      if (warningString.startsWith("VM Modules") || warningString.startsWith("stream/web") || warningString.startsWith("buffer.Blob")) {
        return;
      }
    }
    originalEmitWarning(warning, ctorTypeOptions, ctorCode, ctor);
  };
}
async function main() {
  const [
    { ParseError, buildHelp, parseArgv },
    { Log, LogLevel },
    { Miniflare, PLUGINS }
  ] = await Promise.all([
    import("@miniflare/cli-parser"),
    import("@miniflare/shared"),
    import("miniflare")
  ]);
  let options;
  try {
    options = parseArgv(PLUGINS, process.argv.slice(2));
  } catch (e) {
    if (!(e instanceof ParseError))
      throw e;
    if (e.code === "ERR_VERSION") {
      console.error(e.message);
      return;
    }
    const execName = process.env.MINIFLARE_EXEC_NAME ?? "miniflare";
    console.error(buildHelp(PLUGINS, execName));
    if (e.code === "ERR_HELP")
      return;
    console.error(`
${red(e.message)}`);
    process.exitCode = 1;
    return;
  }
  options.wranglerConfigPath ??= true;
  options.packagePath ??= true;
  options.envPath ??= true;
  if (options.buildWatchPaths?.length || options.liveReload) {
    options.watch = true;
  }
  if (options.durableObjects && Object.keys(options.durableObjects).length) {
    options.modules = true;
  }
  const logLevel = options?.verbose ? LogLevel.VERBOSE : options?.debug ? LogLevel.DEBUG : LogLevel.INFO;
  const mfOptions = options;
  mfOptions.log = new Log(logLevel);
  mfOptions.sourceMap = true;
  const mf = new Miniflare(mfOptions);
  try {
    await mf.startServer();
    await mf.startScheduler();
  } catch (e) {
    mf.log.error(e);
    if (e.cause)
      mf.log.error(e.cause);
    process.exitCode = 1;
    return;
  }
  const plugins = await mf.getPlugins();
  if (plugins.CorePlugin.updateCheck === false)
    return;
  try {
    const pkgFile = path.join(__dirname, "..", "..", "package.json");
    const pkg = JSON.parse(await fs2.readFile(pkgFile, "utf8"));
    const cacheDir = path.resolve("node_modules", ".mf");
    await fs2.mkdir(cacheDir, { recursive: true });
    const lastCheckFile = path.join(cacheDir, "update-check");
    await updateCheck({ pkg, lastCheckFile, log: mf.log });
  } catch (e) {
    mf.log.debug("Unable to check for updates: " + e.stack);
  }
}
suppressWarnings();
void main();
//# sourceMappingURL=cli.js.map
