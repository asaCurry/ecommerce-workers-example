// packages/miniflare/src/api.ts
import { CachePlugin } from "@miniflare/cache";
import {
  BindingsPlugin,
  BuildPlugin,
  CorePlugin,
  MiniflareCore
} from "@miniflare/core";
import {
  DurableObjectsPlugin
} from "@miniflare/durable-objects";
import { HTMLRewriterPlugin } from "@miniflare/html-rewriter";
import { HTTPPlugin, createServer, startServer } from "@miniflare/http-server";
import { KVPlugin } from "@miniflare/kv";
import { VMScriptRunner } from "@miniflare/runner-vm";
import {
  SchedulerPlugin,
  startScheduler
} from "@miniflare/scheduler";
import { NoOpLog } from "@miniflare/shared";
import { SitesPlugin } from "@miniflare/sites";
import { WebSocketPlugin } from "@miniflare/web-sockets";
import sourceMap from "source-map-support";

// packages/miniflare/src/storage.ts
import assert from "assert";
import path from "path";
import { sanitisePath } from "@miniflare/shared";
var redisConnectionStringRegexp = /^rediss?:\/\//;
var VariedStorageFactory = class {
  constructor(memoryStorages = new Map(), redisConnections = new Map()) {
    this.memoryStorages = memoryStorages;
    this.redisConnections = redisConnections;
  }
  async storage(namespace, persist) {
    assert(typeof persist !== "boolean");
    if (persist === void 0) {
      let storage = this.memoryStorages.get(namespace);
      if (storage)
        return storage;
      const { MemoryStorage } = await import("@miniflare/storage-memory");
      this.memoryStorages.set(namespace, storage = new MemoryStorage());
      return storage;
    }
    if (redisConnectionStringRegexp.test(persist)) {
      const { RedisStorage } = await import("@miniflare/storage-redis");
      const IORedis = await import("ioredis");
      let connection = this.redisConnections.get(persist);
      if (!connection) {
        this.redisConnections.set(persist, connection = new IORedis.default(persist));
      }
      return new RedisStorage(connection, namespace);
    }
    const root = path.join(persist, sanitisePath(namespace));
    const { FileStorage } = await import("@miniflare/storage-file");
    return new FileStorage(root);
  }
  async dispose() {
    for (const redisConnection of this.redisConnections.values()) {
      redisConnection.disconnect();
    }
  }
};

// packages/miniflare/src/api.ts
var PLUGINS = {
  CorePlugin,
  HTTPPlugin,
  SchedulerPlugin,
  BuildPlugin,
  KVPlugin,
  DurableObjectsPlugin,
  CachePlugin,
  SitesPlugin,
  HTMLRewriterPlugin,
  WebSocketPlugin,
  BindingsPlugin
};
var Miniflare = class extends MiniflareCore {
  #storageFactory;
  constructor(options) {
    if (options?.sourceMap) {
      sourceMap.install({ emptyCacheBetweenOperations: true });
    }
    const storageFactory = new VariedStorageFactory();
    super(PLUGINS, {
      log: options?.log ?? new NoOpLog(),
      storageFactory,
      scriptRunner: new VMScriptRunner(),
      scriptRequired: true
    }, options);
    this.#storageFactory = storageFactory;
  }
  async dispose() {
    await super.dispose();
    await this.#storageFactory.dispose();
  }
  async getKVNamespace(namespace) {
    const plugin = (await this.getPlugins()).KVPlugin;
    const storage = this.getPluginStorage("KVPlugin");
    return plugin.getNamespace(storage, namespace);
  }
  async getCaches() {
    const plugin = (await this.getPlugins()).CachePlugin;
    return plugin.getCaches();
  }
  async getDurableObjectNamespace(objectName) {
    const plugin = (await this.getPlugins()).DurableObjectsPlugin;
    const storage = this.getPluginStorage("DurableObjectsPlugin");
    return plugin.getNamespace(storage, objectName);
  }
  async getDurableObjectStorage(id) {
    const plugin = (await this.getPlugins()).DurableObjectsPlugin;
    const storage = this.getPluginStorage("DurableObjectsPlugin");
    const state = await plugin.getObject(storage, id);
    return state.storage;
  }
  createServer(options) {
    return createServer(this, options);
  }
  startServer(options) {
    return startServer(this, options);
  }
  startScheduler() {
    return startScheduler(this);
  }
};

// packages/miniflare/src/updater.ts
import fs from "fs/promises";
import semiver from "semiver";
import { fetch } from "undici";
var numericCompare = new Intl.Collator(void 0, { numeric: true }).compare;
async function updateCheck({
  pkg,
  lastCheckFile,
  log,
  now = Date.now(),
  registry = "https://registry.npmjs.org/"
}) {
  let lastCheck = 0;
  try {
    lastCheck = parseInt(await fs.readFile(lastCheckFile, "utf8"));
  } catch {
  }
  if (now - lastCheck < 864e5)
    return;
  const res = await fetch(`${registry}${pkg.name}/latest`, {
    headers: { Accept: "application/json" }
  });
  const registryVersion = (await res.json()).version;
  if (!registryVersion)
    return;
  await fs.writeFile(lastCheckFile, now.toString(), "utf8");
  if (semiver(registryVersion, pkg.version) > 0) {
    log.warn(`Miniflare ${registryVersion} is available, but you're using ${pkg.version}. Update for improved compatibility with Cloudflare Workers.`);
    const registryMajor = registryVersion.split(".")[0];
    const pkgMajor = pkg.version.split(".")[0];
    if (numericCompare(registryMajor, pkgMajor) > 0) {
      log.warn(`${registryVersion} includes breaking changes.Make sure you check the changelog before upgrading.`);
    }
  }
}

// packages/miniflare/src/index.ts
import { Log as Log2, LogLevel } from "@miniflare/shared";
export {
  Log2 as Log,
  LogLevel,
  Miniflare,
  PLUGINS,
  VariedStorageFactory,
  updateCheck
};
//# sourceMappingURL=index.js.map
